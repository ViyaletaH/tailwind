// src/cli.ts
import c8 from "picocolors";

// node_modules/cac/dist/index.mjs
import { EventEmitter } from "events";
function toArr(any) {
  return any == null ? [] : Array.isArray(any) ? any : [any];
}
function toVal(out, key, val, opts) {
  var x, old = out[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? "" : String(val) : typeof val === "boolean" ? val : !!~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
  out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [old, nxt];
}
function mri2(args, opts) {
  args = args || [];
  opts = opts || {};
  var k, arr, arg, name, val, out = { _: [] };
  var i = 0, j = 0, idx = 0, len = args.length;
  const alibi = opts.alias !== void 0;
  const strict = opts.unknown !== void 0;
  const defaults = opts.default !== void 0;
  opts.alias = opts.alias || {};
  opts.string = toArr(opts.string);
  opts.boolean = toArr(opts.boolean);
  if (alibi) {
    for (k in opts.alias) {
      arr = opts.alias[k] = toArr(opts.alias[k]);
      for (i = 0; i < arr.length; i++) {
        (opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
      }
    }
  }
  for (i = opts.boolean.length; i-- > 0; ) {
    arr = opts.alias[opts.boolean[i]] || [];
    for (j = arr.length; j-- > 0; )
      opts.boolean.push(arr[j]);
  }
  for (i = opts.string.length; i-- > 0; ) {
    arr = opts.alias[opts.string[i]] || [];
    for (j = arr.length; j-- > 0; )
      opts.string.push(arr[j]);
  }
  if (defaults) {
    for (k in opts.default) {
      name = typeof opts.default[k];
      arr = opts.alias[k] = opts.alias[k] || [];
      if (opts[name] !== void 0) {
        opts[name].push(k);
        for (i = 0; i < arr.length; i++) {
          opts[name].push(arr[i]);
        }
      }
    }
  }
  const keys = strict ? Object.keys(opts.alias) : [];
  for (i = 0; i < len; i++) {
    arg = args[i];
    if (arg === "--") {
      out._ = out._.concat(args.slice(++i));
      break;
    }
    for (j = 0; j < arg.length; j++) {
      if (arg.charCodeAt(j) !== 45)
        break;
    }
    if (j === 0) {
      out._.push(arg);
    } else if (arg.substring(j, j + 3) === "no-") {
      name = arg.substring(j + 3);
      if (strict && !~keys.indexOf(name)) {
        return opts.unknown(arg);
      }
      out[name] = false;
    } else {
      for (idx = j + 1; idx < arg.length; idx++) {
        if (arg.charCodeAt(idx) === 61)
          break;
      }
      name = arg.substring(j, idx);
      val = arg.substring(++idx) || (i + 1 === len || ("" + args[i + 1]).charCodeAt(0) === 45 || args[++i]);
      arr = j === 2 ? [name] : name;
      for (idx = 0; idx < arr.length; idx++) {
        name = arr[idx];
        if (strict && !~keys.indexOf(name))
          return opts.unknown("-".repeat(j) + name);
        toVal(out, name, idx + 1 < arr.length || val, opts);
      }
    }
  }
  if (defaults) {
    for (k in opts.default) {
      if (out[k] === void 0) {
        out[k] = opts.default[k];
      }
    }
  }
  if (alibi) {
    for (k in out) {
      arr = opts.alias[k] || [];
      while (arr.length > 0) {
        out[arr.shift()] = out[k];
      }
    }
  }
  return out;
}
var removeBrackets = (v) => v.replace(/[<[].+/, "").trim();
var findAllBrackets = (v) => {
  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
  const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
  const res = [];
  const parse = (match) => {
    let variadic = false;
    let value = match[1];
    if (value.startsWith("...")) {
      value = value.slice(3);
      variadic = true;
    }
    return {
      required: match[0].startsWith("<"),
      value,
      variadic
    };
  };
  let angledMatch;
  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(angledMatch));
  }
  let squareMatch;
  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(squareMatch));
  }
  return res;
};
var getMriOptions = (options) => {
  const result = { alias: {}, boolean: [] };
  for (const [index, option] of options.entries()) {
    if (option.names.length > 1) {
      result.alias[option.names[0]] = option.names.slice(1);
    }
    if (option.isBoolean) {
      if (option.negated) {
        const hasStringTypeOption = options.some((o, i) => {
          return i !== index && o.names.some((name) => option.names.includes(name)) && typeof o.required === "boolean";
        });
        if (!hasStringTypeOption) {
          result.boolean.push(option.names[0]);
        }
      } else {
        result.boolean.push(option.names[0]);
      }
    }
  }
  return result;
};
var findLongest = (arr) => {
  return arr.sort((a, b) => {
    return a.length > b.length ? -1 : 1;
  })[0];
};
var padRight = (str, length) => {
  return str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
};
var camelcase = (input) => {
  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
};
var setDotProp = (obj, keys, val) => {
  let i = 0;
  let length = keys.length;
  let t = obj;
  let x;
  for (; i < length; ++i) {
    x = t[keys[i]];
    t = t[keys[i]] = i === length - 1 ? val : x != null ? x : !!~keys[i + 1].indexOf(".") || !(+keys[i + 1] > -1) ? {} : [];
  }
};
var setByType = (obj, transforms) => {
  for (const key of Object.keys(transforms)) {
    const transform = transforms[key];
    if (transform.shouldTransform) {
      obj[key] = Array.prototype.concat.call([], obj[key]);
      if (typeof transform.transformFunction === "function") {
        obj[key] = obj[key].map(transform.transformFunction);
      }
    }
  }
};
var getFileName = (input) => {
  const m = /([^\\\/]+)$/.exec(input);
  return m ? m[1] : "";
};
var camelcaseOptionName = (name) => {
  return name.split(".").map((v, i) => {
    return i === 0 ? camelcase(v) : v;
  }).join(".");
};
var CACError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
};
var Option = class {
  constructor(rawName, description, config) {
    this.rawName = rawName;
    this.description = description;
    this.config = Object.assign({}, config);
    rawName = rawName.replace(/\.\*/g, "");
    this.negated = false;
    this.names = removeBrackets(rawName).split(",").map((v) => {
      let name = v.trim().replace(/^-{1,2}/, "");
      if (name.startsWith("no-")) {
        this.negated = true;
        name = name.replace(/^no-/, "");
      }
      return camelcaseOptionName(name);
    }).sort((a, b) => a.length > b.length ? 1 : -1);
    this.name = this.names[this.names.length - 1];
    if (this.negated && this.config.default == null) {
      this.config.default = true;
    }
    if (rawName.includes("<")) {
      this.required = true;
    } else if (rawName.includes("[")) {
      this.required = false;
    } else {
      this.isBoolean = true;
    }
  }
};
var processArgs = process.argv;
var platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
var Command = class {
  constructor(rawName, description, config = {}, cli2) {
    this.rawName = rawName;
    this.description = description;
    this.config = config;
    this.cli = cli2;
    this.options = [];
    this.aliasNames = [];
    this.name = removeBrackets(rawName);
    this.args = findAllBrackets(rawName);
    this.examples = [];
  }
  usage(text) {
    this.usageText = text;
    return this;
  }
  allowUnknownOptions() {
    this.config.allowUnknownOptions = true;
    return this;
  }
  ignoreOptionDefaultValue() {
    this.config.ignoreOptionDefaultValue = true;
    return this;
  }
  version(version2, customFlags = "-v, --version") {
    this.versionNumber = version2;
    this.option(customFlags, "Display version number");
    return this;
  }
  example(example) {
    this.examples.push(example);
    return this;
  }
  option(rawName, description, config) {
    const option = new Option(rawName, description, config);
    this.options.push(option);
    return this;
  }
  alias(name) {
    this.aliasNames.push(name);
    return this;
  }
  action(callback) {
    this.commandAction = callback;
    return this;
  }
  isMatched(name) {
    return this.name === name || this.aliasNames.includes(name);
  }
  get isDefaultCommand() {
    return this.name === "" || this.aliasNames.includes("!");
  }
  get isGlobalCommand() {
    return this instanceof GlobalCommand;
  }
  hasOption(name) {
    name = name.split(".")[0];
    return this.options.find((option) => {
      return option.names.includes(name);
    });
  }
  outputHelp() {
    const { name, commands } = this.cli;
    const {
      versionNumber,
      options: globalOptions,
      helpCallback
    } = this.cli.globalCommand;
    let sections = [
      {
        body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
      }
    ];
    sections.push({
      title: "Usage",
      body: `  $ ${name} ${this.usageText || this.rawName}`
    });
    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
    if (showCommands) {
      const longestCommandName = findLongest(commands.map((command) => command.rawName));
      sections.push({
        title: "Commands",
        body: commands.map((command) => {
          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;
        }).join("\n")
      });
      sections.push({
        title: `For more info, run any command with the \`--help\` flag`,
        body: commands.map((command) => `  $ ${name}${command.name === "" ? "" : ` ${command.name}`} --help`).join("\n")
      });
    }
    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
    if (!this.isGlobalCommand && !this.isDefaultCommand) {
      options = options.filter((option) => option.name !== "version");
    }
    if (options.length > 0) {
      const longestOptionName = findLongest(options.map((option) => option.rawName));
      sections.push({
        title: "Options",
        body: options.map((option) => {
          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === void 0 ? "" : `(default: ${option.config.default})`}`;
        }).join("\n")
      });
    }
    if (this.examples.length > 0) {
      sections.push({
        title: "Examples",
        body: this.examples.map((example) => {
          if (typeof example === "function") {
            return example(name);
          }
          return example;
        }).join("\n")
      });
    }
    if (helpCallback) {
      sections = helpCallback(sections) || sections;
    }
    console.log(sections.map((section) => {
      return section.title ? `${section.title}:
${section.body}` : section.body;
    }).join("\n\n"));
  }
  outputVersion() {
    const { name } = this.cli;
    const { versionNumber } = this.cli.globalCommand;
    if (versionNumber) {
      console.log(`${name}/${versionNumber} ${platformInfo}`);
    }
  }
  checkRequiredArgs() {
    const minimalArgsCount = this.args.filter((arg) => arg.required).length;
    if (this.cli.args.length < minimalArgsCount) {
      throw new CACError(`missing required args for command \`${this.rawName}\``);
    }
  }
  checkUnknownOptions() {
    const { options, globalCommand } = this.cli;
    if (!this.config.allowUnknownOptions) {
      for (const name of Object.keys(options)) {
        if (name !== "--" && !this.hasOption(name) && !globalCommand.hasOption(name)) {
          throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
        }
      }
    }
  }
  checkOptionValue() {
    const { options: parsedOptions, globalCommand } = this.cli;
    const options = [...globalCommand.options, ...this.options];
    for (const option of options) {
      const value = parsedOptions[option.name.split(".")[0]];
      if (option.required) {
        const hasNegated = options.some((o) => o.negated && o.names.includes(option.name));
        if (value === true || value === false && !hasNegated) {
          throw new CACError(`option \`${option.rawName}\` value is missing`);
        }
      }
    }
  }
};
var GlobalCommand = class extends Command {
  constructor(cli2) {
    super("@@global@@", "", {}, cli2);
  }
};
var __assign = Object.assign;
var CAC = class extends EventEmitter {
  constructor(name = "") {
    super();
    this.name = name;
    this.commands = [];
    this.rawArgs = [];
    this.args = [];
    this.options = {};
    this.globalCommand = new GlobalCommand(this);
    this.globalCommand.usage("<command> [options]");
  }
  usage(text) {
    this.globalCommand.usage(text);
    return this;
  }
  command(rawName, description, config) {
    const command = new Command(rawName, description || "", config, this);
    command.globalCommand = this.globalCommand;
    this.commands.push(command);
    return command;
  }
  option(rawName, description, config) {
    this.globalCommand.option(rawName, description, config);
    return this;
  }
  help(callback) {
    this.globalCommand.option("-h, --help", "Display this message");
    this.globalCommand.helpCallback = callback;
    this.showHelpOnExit = true;
    return this;
  }
  version(version2, customFlags = "-v, --version") {
    this.globalCommand.version(version2, customFlags);
    this.showVersionOnExit = true;
    return this;
  }
  example(example) {
    this.globalCommand.example(example);
    return this;
  }
  outputHelp() {
    if (this.matchedCommand) {
      this.matchedCommand.outputHelp();
    } else {
      this.globalCommand.outputHelp();
    }
  }
  outputVersion() {
    this.globalCommand.outputVersion();
  }
  setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
    this.args = args;
    this.options = options;
    if (matchedCommand) {
      this.matchedCommand = matchedCommand;
    }
    if (matchedCommandName) {
      this.matchedCommandName = matchedCommandName;
    }
    return this;
  }
  unsetMatchedCommand() {
    this.matchedCommand = void 0;
    this.matchedCommandName = void 0;
  }
  parse(argv = processArgs, {
    run = true
  } = {}) {
    this.rawArgs = argv;
    if (!this.name) {
      this.name = argv[1] ? getFileName(argv[1]) : "cli";
    }
    let shouldParse = true;
    for (const command of this.commands) {
      const parsed = this.mri(argv.slice(2), command);
      const commandName = parsed.args[0];
      if (command.isMatched(commandName)) {
        shouldParse = false;
        const parsedInfo = __assign(__assign({}, parsed), {
          args: parsed.args.slice(1)
        });
        this.setParsedInfo(parsedInfo, command, commandName);
        this.emit(`command:${commandName}`, command);
      }
    }
    if (shouldParse) {
      for (const command of this.commands) {
        if (command.name === "") {
          shouldParse = false;
          const parsed = this.mri(argv.slice(2), command);
          this.setParsedInfo(parsed, command);
          this.emit(`command:!`, command);
        }
      }
    }
    if (shouldParse) {
      const parsed = this.mri(argv.slice(2));
      this.setParsedInfo(parsed);
    }
    if (this.options.help && this.showHelpOnExit) {
      this.outputHelp();
      run = false;
      this.unsetMatchedCommand();
    }
    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
      this.outputVersion();
      run = false;
      this.unsetMatchedCommand();
    }
    const parsedArgv = { args: this.args, options: this.options };
    if (run) {
      this.runMatchedCommand();
    }
    if (!this.matchedCommand && this.args[0]) {
      this.emit("command:*");
    }
    return parsedArgv;
  }
  mri(argv, command) {
    const cliOptions = [
      ...this.globalCommand.options,
      ...command ? command.options : []
    ];
    const mriOptions = getMriOptions(cliOptions);
    let argsAfterDoubleDashes = [];
    const doubleDashesIndex = argv.indexOf("--");
    if (doubleDashesIndex > -1) {
      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
      argv = argv.slice(0, doubleDashesIndex);
    }
    let parsed = mri2(argv, mriOptions);
    parsed = Object.keys(parsed).reduce((res, name) => {
      return __assign(__assign({}, res), {
        [camelcaseOptionName(name)]: parsed[name]
      });
    }, { _: [] });
    const args = parsed._;
    const options = {
      "--": argsAfterDoubleDashes
    };
    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
    let transforms = /* @__PURE__ */ Object.create(null);
    for (const cliOption of cliOptions) {
      if (!ignoreDefault && cliOption.config.default !== void 0) {
        for (const name of cliOption.names) {
          options[name] = cliOption.config.default;
        }
      }
      if (Array.isArray(cliOption.config.type)) {
        if (transforms[cliOption.name] === void 0) {
          transforms[cliOption.name] = /* @__PURE__ */ Object.create(null);
          transforms[cliOption.name]["shouldTransform"] = true;
          transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
        }
      }
    }
    for (const key of Object.keys(parsed)) {
      if (key !== "_") {
        const keys = key.split(".");
        setDotProp(options, keys, parsed[key]);
        setByType(options, transforms);
      }
    }
    return {
      args,
      options
    };
  }
  runMatchedCommand() {
    const { args, options, matchedCommand: command } = this;
    if (!command || !command.commandAction)
      return;
    command.checkUnknownOptions();
    command.checkOptionValue();
    command.checkRequiredArgs();
    const actionArgs = [];
    command.args.forEach((arg, index) => {
      if (arg.variadic) {
        actionArgs.push(args.slice(index));
      } else {
        actionArgs.push(args[index]);
      }
    });
    actionArgs.push(options);
    return command.commandAction.apply(this, actionArgs);
  }
};
var cac = (name = "") => new CAC(name);
var dist_default = cac;

// package.json
var version = "3.0.2";

// src/clearCache.ts
import c from "picocolors";
import { clearCache as _clearCache } from "@jspm/generator";
async function clearCache(flags) {
  _clearCache();
  !flags.silent && console.warn(`${c.green("Ok:")} Cache cleared successfully`);
}

// src/install.ts
import c4 from "picocolors";

// src/logger.ts
import fs from "fs/promises";
import os from "os";
import c2 from "picocolors";
var logEnabled = !!process.env.JSPM_CLI_LOG;
var _log;
var _logStream;
if (logEnabled) {
  ({ log: _log, logStream: _logStream } = createLogger());
  try {
    let logPath;
    if (process.env.JSPM_CLI_LOG === "1" || process.env.JSPM_CLI_LOG?.toLowerCase() === "true") {
      logPath = `${os.tmpdir()}/jspm-${new Date().toISOString().slice(0, 19)}.log`;
    } else {
      logPath = process.env.JSPM_CLI_LOG;
    }
    const logWriter = async (msg) => await fs.writeFile(logPath, msg, {
      encoding: "utf-8",
      flag: "a+",
      mode: 438
    });
    (async () => {
      console.log(c2.red(`Creating debug logger at ${logPath}`));
      await logWriter("");
      for await (const { type, message } of _logStream()) {
        const time = new Date().toISOString().slice(11, 23);
        const prefix = c2.bold(`${time} ${type}:`);
        await logWriter(`${prefix} ${message}
`);
      }
    })();
  } catch (e) {
    console.log(c2.red(`Failed to create debug logger: ${e.message}`));
  }
}
function log(type, message) {
  _log && _log(type, message);
}
function withType(type) {
  return (message) => log(type, message);
}
function createLogger() {
  let resolveQueue;
  let queuePromise = new Promise((resolve) => resolveQueue = resolve);
  let queue = [];
  const logStream = async function* () {
    while (true) {
      while (queue.length)
        yield queue.shift();
      await queuePromise;
    }
  };
  function log2(type, message) {
    if (queue.length) {
      queue.push({ type, message });
    } else {
      queue = [{ type, message }];
      const _resolveQueue = resolveQueue;
      queuePromise = new Promise((resolve) => resolveQueue = resolve);
      _resolveQueue();
    }
  }
  return { log: log2, logStream };
}

// src/utils.ts
import fs2 from "fs/promises";
import path from "path";
import { pathToFileURL } from "url";
import { Generator, analyzeHtml } from "@jspm/generator";
import ora from "ora";
import c3 from "picocolors";
var defaultInputPath = "./importmap.json";
var defaultHtmlTemplate = `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>JSPM example</title>
    <script type="importmap"></script>
  </head>
  <body>
  </body>
</html>`;
var availableProviders = [
  "jspm.io",
  "nodemodules",
  "deno",
  "jsdelivr",
  "skypack",
  "unpkg",
  "esm.sh",
  "jspm.io#system"
];
var JspmError = class extends Error {
  jspmError = true;
};
function wrapCommand(fn) {
  return async (...args) => {
    try {
      await fn(...args);
    } catch (e) {
      stopSpinner();
      process.exitCode = 1;
      if (e instanceof JspmError || e?.jspmError) {
        console.error(`${c3.red("Error:")} ${e.message}
`);
        return;
      }
      throw e;
    }
  };
}
async function writeOutput(generator, pins, env, flags, silent = false) {
  if (flags.stdout)
    return writeStdoutOutput(generator, pins, silent);
  const mapFile = getOutputPath(flags);
  if (mapFile.endsWith(".html"))
    return writeHtmlOutput(mapFile, generator, pins, env, flags, silent);
  return writeJsonOutput(mapFile, generator, pins, env, flags, silent);
}
async function writeStdoutOutput(generator, pins, silent = false) {
  let map = pins?.length ? (await generator.extractMap(pins))?.map : generator.getMap();
  map = { ...map };
  !silent && console.log(JSON.stringify(map, null, 2));
  return map;
}
async function writeHtmlOutput(mapFile, generator, pins, env, flags, silent = false) {
  if (!await canWrite(mapFile))
    throw new JspmError(
      `JSPM does not have permission to write to ${mapFile}.`
    );
  const mapFileRel = path.relative(process.cwd(), mapFile);
  if (!await exists(mapFile)) {
    !silent && console.warn(
      `${c3.cyan(
        "Note:"
      )} HTML file ${mapFileRel} does not exist, creating one.`
    );
    await fs2.writeFile(mapFile, defaultHtmlTemplate, "utf-8");
  }
  let html;
  try {
    html = await fs2.readFile(mapFile, "utf-8");
  } catch (e) {
    throw new JspmError(
      `Failed to read HTML file ${c3.cyan(mapFile)} for injection.`
    );
  }
  const outputHtml = await generator.htmlInject(html, {
    pins: pins ?? true,
    htmlUrl: generator.mapUrl,
    // URL of the output map
    rootUrl: generator.rootUrl,
    preload: getPreloadMode(flags),
    integrity: flags.integrity,
    whitespace: !flags.compact,
    comment: false
  });
  await fs2.writeFile(mapFile, outputHtml);
  !silent && console.warn(`${c3.green("Ok:")} Updated ${c3.cyan(mapFileRel)}`);
}
async function writeJsonOutput(mapFile, generator, pins, env, flags, silent = false) {
  const log2 = withType("utils/writeJsonOutput");
  let map;
  if (pins?.length) {
    log2(`Extracting map for top-level pins: ${pins?.join(", ")}`);
    map = (await generator.extractMap(pins))?.map;
  } else {
    log2(`Extracting full map`);
    map = generator.getMap();
  }
  map = { env, ...map };
  log2(`${JSON.stringify(map, null, 2)}`);
  if (!await canWrite(mapFile))
    throw new JspmError(
      `JSPM does not have permission to write to ${mapFile}.`
    );
  try {
    const existing = JSON.parse(await fs2.readFile(mapFile, "utf8"));
    map = Object.assign({}, existing, map);
  } catch {
  }
  await fs2.writeFile(
    mapFile,
    flags.compact ? JSON.stringify(map) : JSON.stringify(map, null, 2)
  );
  const mapFileRel = path.relative(process.cwd(), mapFile);
  !silent && console.warn(`${c3.green("Ok:")} Updated ${c3.cyan(mapFileRel)}`);
  return map;
}
async function getGenerator(flags, setEnv = true) {
  const log2 = withType("utils/getGenerator");
  const mapUrl = getOutputMapUrl(flags);
  const rootUrl = getRootUrl(flags);
  const baseUrl = new URL(path.dirname(mapUrl.href));
  log2(
    `Creating generator with mapUrl ${mapUrl}, baseUrl ${baseUrl}, rootUrl ${rootUrl}`
  );
  return new Generator({
    mapUrl,
    baseUrl,
    rootUrl,
    inputMap: await getInputMap(flags),
    env: setEnv ? await getEnv(flags) : void 0,
    defaultProvider: getProvider(flags),
    resolutions: getResolutions(flags),
    cache: getCacheMode(flags),
    freeze: flags.freeze,
    commonJS: true
    // TODO: only for --local flag
  });
}
async function getInput(flags) {
  const mapFile = getInputPath(flags);
  if (!await exists(mapFile))
    return void 0;
  if (!await canRead(mapFile)) {
    if (mapFile === defaultInputPath)
      return void 0;
    else
      throw new JspmError(`JSPM does not have permission to read ${mapFile}.`);
  }
  return fs2.readFile(mapFile, "utf-8");
}
async function getInputMap(flags) {
  let inputMap;
  const input = await getInput(flags);
  const mapUrl = getOutputMapUrl(flags);
  if (input) {
    try {
      inputMap = JSON.parse(input);
    } catch {
      try {
        const analysis = analyzeHtml(input, mapUrl);
        inputMap = analysis.map;
      } catch {
        throw new JspmError(
          `Input map "${getInputPath(
            flags
          )}" is neither a valid JSON or a HTML file containing an inline import map.`
        );
      }
    }
  }
  return inputMap || {};
}
function getInputPath(flags) {
  return path.resolve(process.cwd(), flags.map || defaultInputPath);
}
function getOutputPath(flags) {
  return path.resolve(
    process.cwd(),
    flags.output || flags.map || defaultInputPath
  );
}
function getOutputMapUrl(flags) {
  return pathToFileURL(getOutputPath(flags));
}
function getRootUrl(flags) {
  if (!flags.root)
    return void 0;
  return pathToFileURL(path.resolve(process.cwd(), flags.root));
}
var excludeDefinitions = {
  production: ["development"],
  development: ["production"],
  node: ["browser", "deno"],
  deno: ["node", "browser"],
  browser: ["node", "deno"]
};
function removeEnvs(env, removeEnvs2) {
  for (const removeEnv of removeEnvs2) {
    if (env.includes(removeEnv))
      env.splice(env.indexOf(removeEnv), 1);
  }
  return env.sort();
}
function addEnvs(env, newEnvs) {
  let excludeEnvs = [];
  for (const newEnv of newEnvs) {
    if (!env.includes(newEnv))
      env.push(newEnv);
    const excludes = excludeDefinitions[newEnv];
    if (excludes)
      excludeEnvs = excludeEnvs.concat(excludes);
  }
  for (const exclude of excludeEnvs) {
    if (env.includes(exclude) && !newEnvs.includes(exclude))
      env.splice(env.indexOf(exclude), 1);
  }
  return env.sort();
}
async function getEnv(flags) {
  const inputMap = await getInputMap(flags);
  const envFlags = Array.isArray(flags.env) ? flags.env : (flags.env || "").split(",").map((e) => e.trim()).filter(Boolean);
  let env = inputMap.env || ["development", "browser", "module"];
  env = removeEnvs(
    env,
    envFlags.filter((env2) => env2.startsWith("no-")).map((env2) => env2.slice(3))
  );
  env = addEnvs(
    env,
    envFlags.filter((env2) => !env2.startsWith("no-"))
  );
  return removeNonStaticEnvKeys(env);
}
function getProvider(flags) {
  if (flags.provider && !availableProviders.includes(flags.provider))
    throw new JspmError(
      `Invalid provider "${flags.provider}". Available providers are: "${availableProviders.join('", "')}".`
    );
  return flags.provider;
}
function removeNonStaticEnvKeys(env) {
  return env.filter(
    (e) => e !== "import" && e !== "require" && e !== "default"
  );
}
function getResolutions(flags) {
  if (!flags.resolution)
    return;
  const resolutions = Array.isArray(flags.resolution) ? flags.resolution : flags.resolution.split(",").map((r) => r.trim());
  return Object.fromEntries(
    resolutions.map((resolution) => {
      if (!resolution.includes("=")) {
        throw new JspmError(
          `Resolutions must be mappings from package names to package versions or specifiers, such as ${c3.bold(
            "--resolution pkg=1.2.3"
          )} or ${c3.bold("--resolution pkg=npm:other@1.2.3")}`
        );
      }
      return resolution.split("=");
    })
  );
}
var validCacheModes = ["online", "offline", "no-cache"];
function getCacheMode(flags) {
  if (!flags.cache)
    return true;
  if (!validCacheModes.includes(flags.cache))
    throw new JspmError(
      `Invalid cache mode "${flags.cache}". Available modes are: "${validCacheModes.join('", "')}".
	${c3.bold(
        "online"
      )}   Use a locally cached module if available and fresh.
	${c3.bold(
        "offline"
      )}   Use a locally cached module if available, even if stale.
	${c3.bold(
        "no-cache"
      )}   Never use the local cache.`
    );
  if (flags.cache === "offline")
    return "offline";
  if (flags.cache === "online")
    return true;
  return false;
}
var validPreloadModes = ["static", "dynamic"];
function getPreloadMode(flags) {
  if (flags.preload === null || flags.preload === void 0)
    return false;
  if (typeof flags.preload === "boolean") {
    return flags.preload;
  }
  if (!validPreloadModes.includes(flags.preload))
    throw new JspmError(
      `Invalid preload mode "${flags.preload}". Available modes are: "${validPreloadModes.join('", "')}" (default).
	${c3.bold(
        "static"
      )}  Inject preload tags for static dependencies.
	${c3.bold(
        "dynamic"
      )} Inject preload tags for static and dynamic dependencies.`
    );
  if (flags.preload === "static")
    return "static";
  if (flags.preload === "dynamic")
    return "all";
  return false;
}
var spinner = ora({ spinner: "dots" });
function startSpinner(text) {
  spinner.start(text);
}
function stopSpinner() {
  spinner.stop();
}
async function exists(file) {
  try {
    await fs2.access(file);
    return true;
  } catch (e) {
    return false;
  }
}
async function canRead(file) {
  try {
    await fs2.access(file, (fs2.constants || fs2).R_OK);
    return true;
  } catch (e) {
    return false;
  }
}
async function canWrite(file) {
  try {
    if (!await exists(file))
      return true;
    await fs2.access(file, (fs2.constants || fs2).W_OK);
    return true;
  } catch (e) {
    return false;
  }
}
function isUrlLikeNotPackage(spec) {
  if (spec.endsWith("/"))
    return false;
  if (spec.startsWith("./") || spec.startsWith("../") || spec.startsWith("/"))
    return true;
  try {
    new URL(spec);
    return spec[spec.indexOf(":") + 1] === "/";
  } catch {
    return false;
  }
}

// src/install.ts
async function install(packages, flags) {
  const log2 = withType("install/install");
  log2(`Installing packages: ${packages.join(", ")}`);
  log2(`Flags: ${JSON.stringify(flags)}`);
  const isInstallable = (p) => !isUrlLikeNotPackage(p.target);
  const parsedPackages = packages.map((p) => {
    if (!p.includes("="))
      return { target: p };
    const [alias, target] = p.split("=");
    return { alias, target };
  });
  const resolvedPackages = parsedPackages.filter(isInstallable);
  const urlLikePackages = parsedPackages.filter((p) => !isInstallable(p));
  const env = await getEnv(flags);
  const input = await getInput(flags);
  const generator = await getGenerator(flags);
  let pins = [];
  if (input) {
    pins = await generator.addMappings(input);
  }
  if (urlLikePackages?.length) {
    const imports = {};
    for (const { alias, target } of urlLikePackages) {
      if (!alias)
        throw new JspmError(
          `URL-like target "${target}" must be given an alias to install under, such as "name=${target}".`
        );
      imports[alias] = target;
    }
    pins.push(...await generator.addMappings(JSON.stringify({ imports })));
  }
  log2(`Input map parsed: ${input}`);
  if (resolvedPackages.length) {
    !flags.silent && startSpinner(
      `Installing ${c4.bold(
        resolvedPackages.map((p) => p.alias || p.target).join(", ")
      )}. (${env.join(", ")})`
    );
    await generator.install(resolvedPackages);
    stopSpinner();
  } else if (pins.length) {
    !flags.silent && startSpinner(`Reinstalling all top-level imports.`);
    await generator.install();
    stopSpinner();
  } else {
    !flags.silent && console.warn(
      `${c4.red(
        "Warning:"
      )} Nothing to install, outputting an empty import map. Either provide a list of package to install, or a non-empty input file.`
    );
  }
  return await writeOutput(generator, null, env, flags, flags.silent);
}

// src/link.ts
import * as fs3 from "node:fs/promises";
import { pathToFileURL as pathToFileURL2 } from "url";
import c5 from "picocolors";
async function link(modules, flags) {
  const log2 = withType("link/link");
  log2(`Linking modules: ${modules.join(", ")}`);
  log2(`Flags: ${JSON.stringify(flags)}`);
  const env = await getEnv(flags);
  const inputMapPath = getInputPath(flags);
  const outputMapPath = getOutputPath(flags);
  const generator = await getGenerator(flags);
  const inlinePins = [];
  const resolvedModules = (await Promise.all(
    modules.map((spec) => resolveModule(spec, inlinePins, generator))
  )).filter((m) => !!m);
  const input = await getInput(flags);
  const pins = inlinePins.concat(resolvedModules.map((p) => p.target));
  let allPins = pins;
  if (input) {
    allPins = pins.concat(await generator.addMappings(input));
  }
  log2(`Input map parsed: ${input}`);
  log2(`Trace installing: ${allPins.concat(pins).join(", ")}`);
  if (allPins.length) {
    if (modules.length === 0) {
      !flags.silent && startSpinner(`Linking input.`);
    } else {
      !flags.silent && startSpinner(
        `Linking ${c5.bold(
          resolvedModules.map((p) => p.alias || p.target).join(", ")
        )}. (${env.join(", ")})`
      );
    }
    await generator.link(allPins.concat(pins));
    stopSpinner();
  } else {
    !flags.silent && console.warn(
      `${c5.red(
        "Warning:"
      )} Found nothing to link, will default to relinking input map. Provide a list of modules or HTML files with inline modules to change this behaviour.`
    );
  }
  if (inputMapPath !== outputMapPath && modules.length !== 0) {
    return await writeOutput(generator, pins, env, flags, flags.silent);
  } else {
    return await writeOutput(generator, null, env, flags, flags.silent);
  }
}
async function resolveModule(p, inlinePins, generator) {
  const log2 = withType("link/resolveModule");
  let res;
  if (p.includes("=")) {
    const [alias, target] = p.split("=");
    res = { alias, target };
  } else {
    res = { target: p };
  }
  if (res.target.startsWith("%")) {
    log2(`Resolving target '${res.target}' as '${res.target.slice(1)}'`);
    res.target = res.target.slice(1);
  } else {
    try {
      await fs3.access(res.target);
      const targetPath = res.target.startsWith(".") || res.target.startsWith("/") ? res.target : `./${res.target}`;
      log2(`Resolving target '${res.target}' as '${targetPath}'`);
      res.target = targetPath;
      return handleLocalFile(res, inlinePins, generator);
    } catch (e) {
    }
  }
  return res;
}
async function handleLocalFile(resolvedModule, inlinePins, generator) {
  const source = await fs3.readFile(resolvedModule.target, { encoding: "utf8" });
  const { default: babel } = await import("@babel/core");
  try {
    babel.parse(source);
    return resolvedModule;
  } catch (e) {
  }
  const targetUrl = pathToFileURL2(resolvedModule.target);
  let pins;
  try {
    pins = await generator.linkHtml(source, targetUrl);
  } catch (e) {
    if (e?.jspmError) {
      e.message += `, linking HTML file "${resolvedModule.target}"`;
    }
    throw e;
  }
  if (!pins || pins.length === 0) {
    throw new Error("No inline HTML modules found to link.");
  }
  inlinePins.push(...pins);
}

// src/uninstall.ts
import c6 from "picocolors";
async function uninstall(packages, flags) {
  const log2 = withType("install/install");
  log2(`Uninstalling packages: ${packages.join(", ")}`);
  log2(`Flags: ${JSON.stringify(flags)}`);
  if (packages.length === 0) {
    !flags.silent && console.warn(
      `${c6.red(
        "Warning:"
      )} Nothing to uninstall. Please provide a list of packages.`
    );
    return;
  }
  const env = await getEnv(flags);
  const input = await getInput(flags);
  const generator = await getGenerator(flags);
  if (typeof input !== "undefined")
    await generator.addMappings(input);
  log2(`Input map parsed: ${input}`);
  !flags.silent && startSpinner(
    `Uninstalling ${c6.bold(packages.join(", "))}. (${env.join(", ")})`
  );
  await generator.uninstall(packages);
  stopSpinner();
  return await writeOutput(generator, null, env, flags, flags.silent);
}

// src/update.ts
import c7 from "picocolors";
async function update(packages, flags) {
  const log2 = withType("update/update");
  log2(`Updating packages: ${packages.join(", ")}`);
  log2(`Flags: ${JSON.stringify(flags)}`);
  const env = await getEnv(flags);
  const generator = await getGenerator(flags);
  let inputPins = [];
  const input = await getInput(flags);
  if (typeof input !== "undefined") {
    inputPins = await generator.addMappings(input);
  }
  log2(`Input map parsed: ${input}`);
  if (packages.length === 0 && inputPins.length === 0) {
    !flags.silent && console.warn(
      `${c7.red(
        "Warning:"
      )} Nothing to update. Please provide a list of packages or a non-empty input file.`
    );
    return;
  } else {
    !flags.silent && startSpinner(
      `Updating ${c7.bold(
        packages.length ? packages.join(", ") : "everything"
      )}. (${env.join(", ")})`
    );
    await generator.update(packages.length ? packages : void 0);
    stopSpinner();
  }
  return await writeOutput(generator, null, env, flags, flags.silent);
}

// src/cli.ts
var cli = dist_default(c8.yellow("jspm"));
var mapOpt = [
  "-m, --map <file>",
  "File containing initial import map",
  { default: "importmap.json" }
];
var envOpt = [
  "-e, --env <environments>",
  "Comma-separated environment condition overrides",
  {}
];
var resolutionOpt = [
  "-r, --resolution <resolutions>",
  "Comma-separated dependency resolution overrides",
  {}
];
var providerOpt = [
  "-p, --provider <provider>",
  `Default module provider. Available providers: ${availableProviders.join(", ")}`,
  {}
];
var stdoutOpt = [
  "--stdout",
  "Output the import map to stdout",
  { default: false }
];
var compactOpt = [
  "--compact",
  "Output a compact import map",
  { default: false }
];
var outputOpt = [
  "-o, --output <file>",
  "File to inject the final import map into (default: --map / importmap.json)",
  {}
];
var preloadOpt = [
  "--preload [mode]",
  "Add module preloads to HTML output (default: static, dynamic)",
  {}
];
var integrityOpt = [
  "--integrity",
  "Add module preloads with integrity attributes to HTML output",
  { default: false }
];
var cacheOpt = [
  "--cache <mode>",
  "Cache mode for fetches (online, offline, no-cache)",
  { default: "online" }
];
var rootOpt = [
  "--root <url>",
  "URL to treat as server root, i.e. rebase import maps against",
  {}
];
var freezeOpt = [
  "--freeze",
  "Freeze input map dependencies, i.e. do not modify them",
  { default: false }
];
var silentOpt = ["--silent", "Silence all output", { default: false }];
cli.option(...silentOpt).version(version).help(defaultHelpCb);
cli.command("[...args]").allowUnknownOptions().usage("[command] [options]").action(
  wrapCommand((args) => {
    if (!args.length)
      return cli.outputHelp();
    throw new JspmError(
      `Unknown command: ${args[0]}
Run "jspm" without any arguments to see the help file.`
    );
  })
);
cli.command("link [...modules]", "link modules").alias("trace").option(...mapOpt).option(...outputOpt).option(...envOpt).option(...resolutionOpt).option(...providerOpt).option(...cacheOpt).option(...rootOpt).option(...preloadOpt).option(...integrityOpt).option(...compactOpt).option(...freezeOpt).option(...stdoutOpt).example(
  (name) => `Link a remote package in importmap.json
  $ ${name} link chalk@5.2.0
`
).example(
  (name) => `Link a local module
  $ ${name} link ./src/cli.js
`
).example(
  (name) => `Link an HTML file and update its import map including preload and integrity tags
  $ ${name} link --map index.html --integrity --preload dynamic
`
).usage(
  `link [flags] [...modules]

Traces and installs all dependencies necessary to execute the given modules into an import map, including both static and dynamic module imports. The given modules can be:
  1. Paths to local JavaScript modules, such as "./src/my-module.mjs".
  2. Paths to local HTML files, such as "index.html", in which case all module scripts in the file are linked.
  3. Valid package specifiers, such as \`react\` or \`chalk@5.2.0\`, in which case the package's main export is linked.
  4. Valid package specifiers with subpaths, such as \`sver@1.1.1/convert-range\`, in which case the subpath is resolved against the package's exports and the resulting module is linked.

In some cases there may be ambiguity. For instance, you may want to link the NPM package "app.js", but your working directory contains a local file called "app.js" as well. In these cases local files are preferred by default, and external packages must be prefixed with the "%" character (i.e. "%app.js").

If no modules are given, all "imports" in the initial map are relinked.`
).action(wrapCommand(link));
cli.command("install [...packages]", "install packages").alias("i").option(...mapOpt).option(...outputOpt).option(...envOpt).option(...resolutionOpt).option(...providerOpt).option(...cacheOpt).option(...rootOpt).option(...preloadOpt).option(...integrityOpt).option(...compactOpt).option(...freezeOpt).option(...stdoutOpt).example(
  (name) => `Install a package
  $ ${name} install lit
`
).example(
  (name) => `Install a versioned package and subpath
  $ ${name} install npm:lit@2.2.0/decorators.js
`
).example(
  (name) => `Install a versioned package
  $ ${name} install npm:react@18.2.0
`
).example(
  (name) => `Install a Denoland package and use the Deno provider
  $ ${name} install -p deno denoload:oak
`
).example(
  (name) => `Install "alias" as an alias of the resolution react
  $ ${name} install alias=react
`
).usage(
  `install [flags] [...packages]

Installs packages into an import map, along with all of the dependencies that are necessary to import them.By default, the latest versions of the packages that are compatible with the local "package.json" are installed, unless an explicit version is specified. The given packages must be valid package specifiers, such as \`npm:react@18.0.0\` or \`denoland:oak\`. If a package specifier with no registry is given, such as \`lit\`, the registry is assumed to be NPM. Packages can be installed under an alias by using specifiers such as \`myname=npm:lit@2.1.0\`. An optional subpath can be provided, such as \`npm:lit@2.2.0/decorators.js\`, in which case only the dependencies for that subpath are installed.

If no packages are provided, all "imports" in the initial map are reinstalled.`
).action(wrapCommand(install));
cli.command("uninstall [...packages]", "remove packages").option(...mapOpt).option(...outputOpt).option(...envOpt).option(...resolutionOpt).option(...providerOpt).option(...cacheOpt).option(...rootOpt).option(...preloadOpt).option(...integrityOpt).option(...compactOpt).option(...freezeOpt).option(...stdoutOpt).example(
  (name) => `
$ ${name} uninstall lit lodash

Uninstall "lit" and "lodash" from importmap.json.
`
).usage(
  `uninstall [flags] [...packages]

Uninstalls packages from an import map. The given packages must be valid package specifiers, such as \`npm:react@18.0.0\`, \`denoland:oak\` or \`lit\`, and must be present in the initial import map.`
).action(wrapCommand(uninstall));
cli.command("update [...packages]", "update packages").alias("upgrade").option(...mapOpt).option(...outputOpt).option(...envOpt).option(...resolutionOpt).option(...providerOpt).option(...cacheOpt).option(...rootOpt).option(...preloadOpt).option(...integrityOpt).option(...compactOpt).option(...freezeOpt).option(...stdoutOpt).example(
  (name) => `
$ ${name} update react-dom

Update the react-dom package.
`
).usage(
  `update [flags] [...packages]

Updates packages in an import map to the latest versions that are compatible with the local \`package.json\`. The given packages must be valid package specifiers, such as \`npm:react@18.0.0\`, \`denoland:oak\` or \`lit\`, and must be present in the initial import map.`
).action(wrapCommand(update));
cli.command("clear-cache", "clear the local package cache").usage(
  `clear-cache

Clears the global module fetch cache, for situations where the contents of a dependency may have changed without a version bump. This can happen during local development, for instance.`
).alias("cc").action(wrapCommand(clearCache));
function defaultHelpCb(helpSections) {
  for (const section of Object.values(helpSections)) {
    if (section.title === "Commands") {
      section.body = section.body.split("\n").slice(1).join("\n");
    }
  }
  for (const section of Object.values(helpSections)) {
    if (section.title)
      section.title = c8.bold(section.title);
  }
  return helpSections;
}
export {
  cli
};
