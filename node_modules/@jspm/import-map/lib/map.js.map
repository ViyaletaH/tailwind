{"version":3,"sources":["../src/map.ts"],"names":[],"mappings":"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","file":"map.js","sourcesContent":["import {\r\n  baseUrl,\r\n  rebase,\r\n  isPlain,\r\n  isURL,\r\n  getCommonBase,\r\n  resolve,\r\n  sameOrigin,\r\n} from \"./url.js\";\r\nimport { alphabetize } from \"./alphabetize.js\";\r\n\r\nexport interface IImportMap {\r\n  imports?: Record<string, string>;\r\n  scopes?: {\r\n    [scope: string]: Record<string, string>;\r\n  };\r\n}\r\n\r\nexport class ImportMap implements IImportMap {\r\n  imports: Record<string, string> = Object.create(null);\r\n  scopes: Record<string, Record<string, string>> = Object.create(null);\r\n\r\n  /**\r\n   * The absolute URL of the import map, for determining relative resolutions\r\n   * When using file:/// URLs this allows relative modules to be co-located\r\n   */\r\n  mapUrl: URL;\r\n  /**\r\n   * The URL to use for root-level resolutions in the import map\r\n   * If null, root resolutions are not resolved and instead left as-is\r\n   *\r\n   * By default, rootUrl is null unless the mapUrl is an http or https URL,\r\n   * in which case it is taken to be the root of the mapUrl.\r\n   */\r\n  rootUrl: URL | null;\r\n\r\n  /**\r\n   * Create a new import map instance\r\n   *\r\n   * @param opts import map options, can be an optional bag of { map?, mapUrl?, rootUrl? } or just a direct mapUrl\r\n   */\r\n  constructor(\r\n    opts:\r\n      | {\r\n          map?: IImportMap;\r\n          mapUrl?: string | URL;\r\n          rootUrl?: string | URL | null;\r\n        }\r\n      | string\r\n      | URL\r\n  ) {\r\n    let {\r\n      map,\r\n      mapUrl = baseUrl,\r\n      rootUrl,\r\n    } = opts instanceof URL ||\r\n    typeof opts === \"string\" ||\r\n    typeof opts === \"undefined\"\r\n      ? { mapUrl: opts, map: undefined, rootUrl: undefined }\r\n      : opts;\r\n    if (typeof mapUrl === \"string\") mapUrl = new URL(mapUrl);\r\n    this.mapUrl = mapUrl;\r\n    if (\r\n      rootUrl === undefined &&\r\n      (this.mapUrl.protocol === \"http:\" || this.mapUrl.protocol === \"https:\")\r\n    )\r\n      rootUrl = new URL(\"/\", this.mapUrl);\r\n    else if (typeof rootUrl === \"string\") rootUrl = new URL(rootUrl);\r\n    this.rootUrl = rootUrl || null;\r\n    if (map) this.extend(map);\r\n  }\r\n\r\n  /**\r\n   * Clones the import map\r\n   * @returns Cloned import map\r\n   */\r\n  clone() {\r\n    return new ImportMap({ mapUrl: this.mapUrl, rootUrl: this.rootUrl }).extend(\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Extends the import map mappings\r\n   * @param map Import map to extend with\r\n   * @param overrideScopes Set to true to have scopes be replacing instead of extending\r\n   * @returns ImportMap for chaining\r\n   */\r\n  extend(map: IImportMap, overrideScopes = false) {\r\n    Object.assign(this.imports, map.imports);\r\n    if (overrideScopes) {\r\n      Object.assign(this.scopes, map.scopes);\r\n    } else if (map.scopes) {\r\n      for (const scope of Object.keys(map.scopes))\r\n        Object.assign(\r\n          (this.scopes[scope] = this.scopes[scope] || Object.create(null)),\r\n          map.scopes[scope]\r\n        );\r\n    }\r\n    this.rebase();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Performs an alphanumerical sort on the import map imports and scopes\r\n   * @returns ImportMap for chaining\r\n   */\r\n  sort() {\r\n    this.imports = alphabetize(this.imports);\r\n    this.scopes = alphabetize(this.scopes);\r\n    for (const scope of Object.keys(this.scopes))\r\n      this.scopes[scope] = alphabetize(this.scopes[scope]);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set a specific entry in the import map\r\n   *\r\n   * @param name Specifier to set\r\n   * @param target Target of the map\r\n   * @param parent Optional parent scope\r\n   * @returns ImportMap for chaining\r\n   */\r\n  set(name: string, target: string, parent?: string) {\r\n    if (!parent) {\r\n      this.imports[name] = target;\r\n    } else {\r\n      this.scopes[parent] = this.scopes[parent] || Object.create(null);\r\n      this.scopes[parent][name] = target;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Bulk replace URLs in the import map\r\n   * Provide a URL ending in \"/\" to perform path replacements\r\n   *\r\n   * @param url {String} The URL to replace\r\n   * @param newUrl {String} The URL to replace it with\r\n   * @returns ImportMap for chaining\r\n   */\r\n  replace(url: string, newUrl: string) {\r\n    const replaceSubpaths = url.endsWith(\"/\");\r\n    if (!isURL(url)) throw new Error(\"URL remapping only supports URLs\");\r\n    const newRelPkgUrl = rebase(newUrl, this.mapUrl, this.rootUrl);\r\n    for (const impt of Object.keys(this.imports)) {\r\n      const target = this.imports[impt];\r\n      if ((replaceSubpaths && target.startsWith(url)) || target === url)\r\n        this.imports[impt] = newRelPkgUrl + target.slice(url.length);\r\n    }\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const scopeImports = this.scopes[scope];\r\n      const scopeUrl = resolve(scope, this.mapUrl, this.rootUrl);\r\n      if ((replaceSubpaths && scopeUrl.startsWith(url)) || scopeUrl === url) {\r\n        const newScope = newRelPkgUrl + scopeUrl.slice(url.length);\r\n        delete this.scopes[scope];\r\n        this.scopes[newScope] = scopeImports;\r\n      }\r\n      for (const impt of Object.keys(scopeImports)) {\r\n        const target = scopeImports[impt];\r\n        if ((replaceSubpaths && target.startsWith(url)) || target === url)\r\n          scopeImports[impt] = newRelPkgUrl + target.slice(url.length);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Groups subpath mappings into path mappings when multiple exact subpaths\r\n   * exist under the same path.\r\n   *\r\n   * For two mappings like { \"base/a.js\": \"/a.js\", \"base/b.js\": \"/b.js\" },\r\n   * these will be replaced with a single path mapping { \"base/\": \"/\" }.\r\n   * Groupings are done throughout all import scopes individually.\r\n   *\r\n   * @returns ImportMap for chaining\r\n   */\r\n  combineSubpaths() {\r\n    // iterate possible bases and submappings, grouping bases greedily\r\n    const combineSubpathMappings = (mappings: Record<string, string>) => {\r\n      let outMappings: Record<string, string> = Object.create(null);\r\n      for (let impt of Object.keys(mappings)) {\r\n        const target = mappings[impt];\r\n        // Check if this import is already handled by an existing path mapping\r\n        // If so, either merge with it or continue on\r\n        let mapMatch;\r\n        if (isPlain(impt)) {\r\n          mapMatch = getMapMatch(impt, outMappings);\r\n        } else {\r\n          mapMatch =\r\n            getMapMatch(\r\n              (impt = rebase(impt, this.mapUrl, this.rootUrl)),\r\n              outMappings\r\n            ) ||\r\n            (this.rootUrl &&\r\n              getMapMatch(\r\n                (impt = rebase(impt, this.mapUrl, null)),\r\n                outMappings\r\n              )) ||\r\n            undefined;\r\n        }\r\n        if (\r\n          mapMatch &&\r\n          impt.slice(mapMatch.length) ===\r\n            resolve(target, this.mapUrl, this.rootUrl).slice(\r\n              resolve(outMappings[mapMatch], this.mapUrl, this.rootUrl).length\r\n            )\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        let newbase = false;\r\n        const targetParts = mappings[impt].split(\"/\");\r\n        const imptParts = impt.split(\"/\");\r\n        for (let j = imptParts.length - 1; j > 0; j--) {\r\n          const subpath = imptParts.slice(j).join(\"/\");\r\n          const subpathTarget = targetParts\r\n            .slice(targetParts.length - (imptParts.length - j))\r\n            .join(\"/\");\r\n          if (subpath !== subpathTarget) {\r\n            outMappings[impt] = mappings[impt];\r\n            break;\r\n          }\r\n          const base = imptParts.slice(0, j).join(\"/\") + \"/\";\r\n          if (outMappings[base]) continue;\r\n          const baseTarget =\r\n            targetParts\r\n              .slice(0, targetParts.length - (imptParts.length - j))\r\n              .join(\"/\") + \"/\";\r\n\r\n          // Dedupe existing mappings against the new base to remove them\r\n          // And if we dont dedupe against anything then dont perform this basing\r\n          for (let impt of Object.keys(outMappings)) {\r\n            const target = outMappings[impt];\r\n            let matches = false;\r\n            if (isPlain(impt)) {\r\n              matches = impt.startsWith(base);\r\n            } else {\r\n              matches =\r\n                (impt = rebase(impt, this.mapUrl, this.rootUrl)).startsWith(\r\n                  base\r\n                ) ||\r\n                (impt = rebase(impt, this.mapUrl, this.rootUrl)).startsWith(\r\n                  base\r\n                );\r\n            }\r\n            if (\r\n              matches &&\r\n              impt.slice(base.length) ===\r\n                resolve(target, this.mapUrl, this.rootUrl).slice(\r\n                  resolve(baseTarget, this.mapUrl, this.rootUrl).length\r\n                )\r\n            ) {\r\n              newbase = true;\r\n              delete outMappings[impt];\r\n            }\r\n          }\r\n\r\n          if (newbase) {\r\n            outMappings[base] = baseTarget;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!newbase) outMappings[impt] = target;\r\n      }\r\n      return outMappings;\r\n    };\r\n\r\n    // Only applies for scopes since \"imports\" are generally treated as\r\n    // an authoritative entry point list\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      this.scopes[scope] = combineSubpathMappings(this.scopes[scope]);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Groups the import map scopes to shared URLs to reduce duplicate mappings.\r\n   *\r\n   * For two given scopes, \"https://site.com/x/\" and \"https://site.com/y/\",\r\n   * a single scope will be constructed for \"https://site.com/\" including\r\n   * their shared mappings, only retaining the scopes if they have differences.\r\n   *\r\n   * In the case where the scope is on the same origin as the mapUrl, the grouped\r\n   * scope is determined based on determining the common baseline over all local scopes\r\n   *\r\n   * @returns ImportMap for chaining\r\n   */\r\n  flatten() {\r\n    // First, determine the common base for the local mappings if any\r\n    let localScopemapUrl: string | null = null;\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const resolvedScope = resolve(scope, this.mapUrl, this.rootUrl);\r\n      if (isURL(resolvedScope)) {\r\n        const scopeUrl = new URL(resolvedScope);\r\n        if (sameOrigin(scopeUrl, this.mapUrl)) {\r\n          if (!localScopemapUrl) localScopemapUrl = scopeUrl.href;\r\n          else\r\n            localScopemapUrl = getCommonBase(scopeUrl.href, localScopemapUrl);\r\n        }\r\n      } else {\r\n        if (!localScopemapUrl) localScopemapUrl = resolvedScope;\r\n        else localScopemapUrl = getCommonBase(resolvedScope, localScopemapUrl);\r\n      }\r\n    }\r\n\r\n    // for each scope, update its mappings to be in the shared base where possible\r\n    const relativeLocalScopemapUrl = localScopemapUrl\r\n      ? rebase(localScopemapUrl, this.mapUrl, this.rootUrl)\r\n      : null;\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const scopeImports = this.scopes[scope];\r\n\r\n      let scopemapUrl: string;\r\n      const resolvedScope = resolve(scope, this.mapUrl, this.rootUrl);\r\n      if (isURL(resolvedScope)) {\r\n        const scopeUrl = new URL(resolvedScope);\r\n        if (sameOrigin(scopeUrl, this.mapUrl)) {\r\n          scopemapUrl = relativeLocalScopemapUrl;\r\n        } else {\r\n          scopemapUrl =\r\n            scopeUrl.protocol +\r\n            \"//\" +\r\n            scopeUrl.hostname +\r\n            (scopeUrl.port ? \":\" + scopeUrl.port : \"\") +\r\n            \"/\";\r\n        }\r\n      } else {\r\n        scopemapUrl = relativeLocalScopemapUrl;\r\n      }\r\n\r\n      let scopeBase: Record<string, string> | null =\r\n        this.scopes[scopemapUrl] || Object.create(null);\r\n      if (scopeBase === scopeImports) scopeBase = null;\r\n\r\n      let flattenedAll = true;\r\n      for (const name of Object.keys(scopeImports)) {\r\n        const target = scopeImports[name];\r\n        if (\r\n          this.imports[name] &&\r\n          resolve(this.imports[name], this.mapUrl, this.rootUrl) ===\r\n            resolve(target, this.mapUrl, this.rootUrl)\r\n        ) {\r\n          delete scopeImports[name];\r\n        } else if (\r\n          scopeBase &&\r\n          (!scopeBase[name] ||\r\n            resolve(scopeBase[name], this.mapUrl, this.rootUrl) ===\r\n              resolve(target, this.mapUrl, this.rootUrl))\r\n        ) {\r\n          scopeBase[name] = rebase(target, this.mapUrl, this.rootUrl);\r\n          delete scopeImports[name];\r\n          this.scopes[<string>scopemapUrl] = alphabetize(scopeBase);\r\n        } else {\r\n          flattenedAll = false;\r\n        }\r\n      }\r\n      if (flattenedAll) delete this.scopes[scope];\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rebase the entire import map to a new mapUrl and rootUrl\r\n   *\r\n   * If the rootUrl is not provided, it will remain null if it was\r\n   * already set to null.\r\n   *\r\n   * Otherwise, just like the constructor options, the rootUrl\r\n   * will default to the mapUrl base if it is an http: or https:\r\n   * scheme URL, and null otherwise keeping absolute URLs entirely\r\n   * in-tact.\r\n   *\r\n   * @param mapUrl The new map URL to use\r\n   * @param rootUrl The new root URL to use\r\n   * @returns ImportMap for chaining\r\n   */\r\n  rebase(mapUrl: URL | string = this.mapUrl, rootUrl?: URL | string | null) {\r\n    if (typeof mapUrl === \"string\") mapUrl = new URL(mapUrl);\r\n    if (rootUrl === undefined) {\r\n      if (mapUrl.href === this.mapUrl.href) rootUrl = this.rootUrl;\r\n      else\r\n        rootUrl =\r\n          this.rootUrl === null ||\r\n          (mapUrl.protocol !== \"https:\" && mapUrl.protocol !== \"http:\")\r\n            ? null\r\n            : new URL(\"/\", mapUrl);\r\n    } else if (typeof rootUrl === \"string\") rootUrl = new URL(rootUrl);\r\n    let changedImportProps = false;\r\n    for (const impt of Object.keys(this.imports)) {\r\n      const target = this.imports[impt];\r\n      this.imports[impt] = rebase(\r\n        resolve(target, this.mapUrl, this.rootUrl),\r\n        mapUrl,\r\n        rootUrl\r\n      );\r\n      if (!isPlain(impt)) {\r\n        const newImpt = rebase(\r\n          resolve(impt, this.mapUrl, this.rootUrl),\r\n          mapUrl,\r\n          rootUrl\r\n        );\r\n        if (newImpt !== impt) {\r\n          changedImportProps = true;\r\n          this.imports[newImpt] = this.imports[impt];\r\n          delete this.imports[impt];\r\n        }\r\n      }\r\n    }\r\n    if (changedImportProps) this.imports = alphabetize(this.imports);\r\n    let changedScopeProps = false;\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const scopeImports = this.scopes[scope];\r\n      let changedScopeImportProps = false;\r\n      for (const impt of Object.keys(scopeImports)) {\r\n        const target = scopeImports[impt];\r\n        scopeImports[impt] = rebase(\r\n          resolve(target, this.mapUrl, this.rootUrl),\r\n          mapUrl,\r\n          rootUrl\r\n        );\r\n        if (!isPlain(impt)) {\r\n          const newName = rebase(\r\n            resolve(impt, this.mapUrl, this.rootUrl),\r\n            mapUrl,\r\n            rootUrl\r\n          );\r\n          if (newName !== impt) {\r\n            changedScopeImportProps = true;\r\n            scopeImports[newName] = scopeImports[impt];\r\n            delete scopeImports[impt];\r\n          }\r\n        }\r\n      }\r\n      if (changedScopeImportProps)\r\n        this.scopes[scope] = alphabetize(scopeImports);\r\n      const newScope = rebase(\r\n        resolve(scope, this.mapUrl, this.rootUrl),\r\n        mapUrl,\r\n        rootUrl\r\n      );\r\n      if (scope !== newScope) {\r\n        changedScopeProps = true;\r\n        delete this.scopes[scope];\r\n        this.scopes[newScope] = scopeImports;\r\n      }\r\n    }\r\n    if (changedScopeProps) this.scopes = alphabetize(this.scopes);\r\n    this.mapUrl = mapUrl;\r\n    this.rootUrl = rootUrl;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Perform a module resolution against the import map\r\n   *\r\n   * @param specifier Specifier to resolve\r\n   * @param parentUrl Parent URL to resolve against\r\n   * @returns Resolved URL string\r\n   */\r\n  resolve(specifier: string, parentUrl: string | URL = this.mapUrl): string {\r\n    if (typeof parentUrl !== \"string\") parentUrl = parentUrl.toString();\r\n    parentUrl = resolve(parentUrl, this.mapUrl, this.rootUrl);\r\n    let specifierUrl: URL | undefined;\r\n    if (!isPlain(specifier)) {\r\n      specifierUrl = new URL(specifier, parentUrl);\r\n      specifier = specifierUrl.href;\r\n    }\r\n    const scopeMatches = getScopeMatches(\r\n      parentUrl,\r\n      this.scopes,\r\n      this.mapUrl,\r\n      this.rootUrl\r\n    );\r\n    for (const [scope] of scopeMatches) {\r\n      let mapMatch = getMapMatch(specifier, this.scopes[scope]);\r\n      if (!mapMatch && specifierUrl) {\r\n        mapMatch =\r\n          getMapMatch(\r\n            (specifier = rebase(specifier, this.mapUrl, this.rootUrl)),\r\n            this.scopes[scope]\r\n          ) ||\r\n          (this.rootUrl &&\r\n            getMapMatch(\r\n              (specifier = rebase(specifier, this.mapUrl, null)),\r\n              this.scopes[scope]\r\n            )) ||\r\n          undefined;\r\n      }\r\n      if (mapMatch) {\r\n        const target = this.scopes[scope][mapMatch];\r\n        return resolve(\r\n          target + specifier.slice(mapMatch.length),\r\n          this.mapUrl,\r\n          this.rootUrl\r\n        );\r\n      }\r\n    }\r\n    let mapMatch = getMapMatch(specifier, this.imports);\r\n    if (!mapMatch && specifierUrl) {\r\n      mapMatch =\r\n        getMapMatch(\r\n          (specifier = rebase(specifier, this.mapUrl, this.rootUrl)),\r\n          this.imports\r\n        ) ||\r\n        (this.rootUrl &&\r\n          getMapMatch(\r\n            (specifier = rebase(specifier, this.mapUrl, null)),\r\n            this.imports\r\n          )) ||\r\n        undefined;\r\n    }\r\n    if (mapMatch) {\r\n      const target = this.imports[mapMatch];\r\n      return resolve(\r\n        target + specifier.slice(mapMatch.length),\r\n        this.mapUrl,\r\n        this.rootUrl\r\n      );\r\n    }\r\n    if (specifierUrl) return specifierUrl.href;\r\n    throw new Error(`Unable to resolve ${specifier} in ${parentUrl}`);\r\n  }\r\n\r\n  /**\r\n   * Get the import map JSON data\r\n   *\r\n   * @returns Import map data\r\n   */\r\n  toJSON(): IImportMap {\r\n    const obj: any = {};\r\n    if (Object.keys(this.imports).length) obj.imports = this.imports;\r\n    if (Object.keys(this.scopes).length) obj.scopes = this.scopes;\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n}\r\n\r\nexport function getScopeMatches(\r\n  parentUrl: string,\r\n  scopes: Record<string, Record<string, string>>,\r\n  mapUrl: URL,\r\n  rootUrl?: URL\r\n): [string, string][] {\r\n  let scopeCandidates = Object.keys(scopes).map((scope) => [\r\n    scope,\r\n    resolve(scope, mapUrl, rootUrl),\r\n  ]);\r\n  scopeCandidates = scopeCandidates.sort(([, matchA], [, matchB]) =>\r\n    matchA.length < matchB.length ? 1 : -1\r\n  );\r\n\r\n  return scopeCandidates.filter(([, scopeUrl]) => {\r\n    return (\r\n      scopeUrl === parentUrl ||\r\n      (scopeUrl.endsWith(\"/\") && parentUrl.startsWith(scopeUrl))\r\n    );\r\n  }) as [string, string][];\r\n}\r\n\r\nexport function getMapMatch<T = any>(\r\n  specifier: string,\r\n  map: Record<string, T>\r\n): string | undefined {\r\n  if (specifier in map) return specifier;\r\n  let curMatch;\r\n  for (const match of Object.keys(map)) {\r\n    const wildcard = match.endsWith(\"*\");\r\n    if (!match.endsWith(\"/\") && !wildcard) continue;\r\n    if (specifier.startsWith(wildcard ? match.slice(0, -1) : match)) {\r\n      if (!curMatch || match.length > curMatch.length) curMatch = match;\r\n    }\r\n  }\r\n  return curMatch;\r\n}\r\n"]}