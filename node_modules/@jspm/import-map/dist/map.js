var ref;
let baseUrl;
// @ts-ignore
if (typeof Deno !== "undefined") {
    // @ts-ignore
    baseUrl = new URL("file://" + Deno.cwd() + "/");
} else if (typeof process !== "undefined" && ((ref = process.versions) === null || ref === void 0 ? void 0 : ref.node)) {
    baseUrl = new URL("file://" + process.cwd() + "/");
} else if (typeof document !== "undefined") {
    const baseEl = document.querySelector("base[href]");
    if (baseEl) baseUrl = new URL(baseEl.href + (baseEl.href.endsWith("/") ? "" : "/"));
    else if (typeof location !== "undefined") baseUrl = new URL("../", new URL(location.href));
}
function getCommonBase(a, b) {
    if (a.startsWith(b)) return b;
    if (b.startsWith(a)) return a;
    const aSegments = a.split("/");
    const bSegments = b.split("/");
    let i = 0;
    while(aSegments[i] === bSegments[i])i++;
    return aSegments.slice(0, i).join("/") + "/";
}
function sameOrigin(url, baseUrl) {
    return url.protocol === baseUrl.protocol && url.host === baseUrl.host && url.port === baseUrl.port && url.username === baseUrl.username && url.password === baseUrl.password;
}
function resolve(url, mapUrl, rootUrl) {
    if (url.startsWith("/")) return rootUrl ? new URL("." + url.slice(url[1] === "/" ? 1 : 0), rootUrl).href : url;
    return new URL(url, mapUrl).href;
}
function rebase(url, baseUrl, rootUrl = null) {
    let resolved;
    if (url.startsWith("/") || url.startsWith("//")) {
        if (rootUrl === null) return url;
        resolved = new URL(url, rootUrl);
    } else {
        resolved = new URL(url, baseUrl);
    }
    if (rootUrl && resolved.href.startsWith(rootUrl.href)) return resolved.href.slice(rootUrl.href.length - 1);
    if (rootUrl && rootUrl.href.startsWith(resolved.href)) {
        // edge-case
        return "/" + relative(resolved, rootUrl);
    }
    if (sameOrigin(resolved, baseUrl)) return relative(resolved, baseUrl);
    return resolved.href;
}
function relative(url, baseUrl) {
    const baseUrlPath = baseUrl.pathname;
    const urlPath = url.pathname;
    const minLen = Math.min(baseUrlPath.length, urlPath.length);
    let sharedBaseIndex = -1;
    for(let i = 0; i < minLen; i++){
        if (baseUrlPath[i] !== urlPath[i]) break;
        if (urlPath[i] === "/") sharedBaseIndex = i;
    }
    const backtracks = baseUrlPath.slice(sharedBaseIndex + 1).split("/").length - 1;
    return (backtracks ? "../".repeat(backtracks) : "./") + urlPath.slice(sharedBaseIndex + 1) + url.search + url.hash;
}
function isURL(specifier) {
    try {
        if (specifier[0] === "#") return false;
        new URL(specifier);
    } catch (e) {
        return false;
    }
    return true;
}
function isPlain(specifier) {
    return !isRelative(specifier) && !isURL(specifier);
}
function isRelative(specifier) {
    return specifier.startsWith("./") || specifier.startsWith("../") || specifier.startsWith("/");
}

function alphabetize(obj) {
    const out = {};
    for (const key of Object.keys(obj).sort())out[key] = obj[key];
    return out;
}

class ImportMap {
    /**
   * Clones the import map
   * @returns Cloned import map
   */ clone() {
        return new ImportMap({
            mapUrl: this.mapUrl,
            rootUrl: this.rootUrl
        }).extend(this);
    }
    /**
   * Extends the import map mappings
   * @param map Import map to extend with
   * @param overrideScopes Set to true to have scopes be replacing instead of extending
   * @returns ImportMap for chaining
   */ extend(map, overrideScopes = false) {
        Object.assign(this.imports, map.imports);
        if (overrideScopes) {
            Object.assign(this.scopes, map.scopes);
        } else if (map.scopes) {
            for (const scope of Object.keys(map.scopes))Object.assign(this.scopes[scope] = this.scopes[scope] || Object.create(null), map.scopes[scope]);
        }
        this.rebase();
        return this;
    }
    /**
   * Performs an alphanumerical sort on the import map imports and scopes
   * @returns ImportMap for chaining
   */ sort() {
        this.imports = alphabetize(this.imports);
        this.scopes = alphabetize(this.scopes);
        for (const scope of Object.keys(this.scopes))this.scopes[scope] = alphabetize(this.scopes[scope]);
        return this;
    }
    /**
   * Set a specific entry in the import map
   *
   * @param name Specifier to set
   * @param target Target of the map
   * @param parent Optional parent scope
   * @returns ImportMap for chaining
   */ set(name, target, parent) {
        if (!parent) {
            this.imports[name] = target;
        } else {
            this.scopes[parent] = this.scopes[parent] || Object.create(null);
            this.scopes[parent][name] = target;
        }
        return this;
    }
    /**
   * Bulk replace URLs in the import map
   * Provide a URL ending in "/" to perform path replacements
   *
   * @param url {String} The URL to replace
   * @param newUrl {String} The URL to replace it with
   * @returns ImportMap for chaining
   */ replace(url, newUrl) {
        const replaceSubpaths = url.endsWith("/");
        if (!isURL(url)) throw new Error("URL remapping only supports URLs");
        const newRelPkgUrl = rebase(newUrl, this.mapUrl, this.rootUrl);
        for (const impt of Object.keys(this.imports)){
            const target = this.imports[impt];
            if (replaceSubpaths && target.startsWith(url) || target === url) this.imports[impt] = newRelPkgUrl + target.slice(url.length);
        }
        for (const scope of Object.keys(this.scopes)){
            const scopeImports = this.scopes[scope];
            const scopeUrl = resolve(scope, this.mapUrl, this.rootUrl);
            if (replaceSubpaths && scopeUrl.startsWith(url) || scopeUrl === url) {
                const newScope = newRelPkgUrl + scopeUrl.slice(url.length);
                delete this.scopes[scope];
                this.scopes[newScope] = scopeImports;
            }
            for (const impt1 of Object.keys(scopeImports)){
                const target1 = scopeImports[impt1];
                if (replaceSubpaths && target1.startsWith(url) || target1 === url) scopeImports[impt1] = newRelPkgUrl + target1.slice(url.length);
            }
        }
        return this;
    }
    /**
   * Groups subpath mappings into path mappings when multiple exact subpaths
   * exist under the same path.
   *
   * For two mappings like { "base/a.js": "/a.js", "base/b.js": "/b.js" },
   * these will be replaced with a single path mapping { "base/": "/" }.
   * Groupings are done throughout all import scopes individually.
   *
   * @returns ImportMap for chaining
   */ combineSubpaths() {
        // iterate possible bases and submappings, grouping bases greedily
        const combineSubpathMappings = (mappings)=>{
            let outMappings = Object.create(null);
            for (let impt of Object.keys(mappings)){
                const target = mappings[impt];
                // Check if this import is already handled by an existing path mapping
                // If so, either merge with it or continue on
                let mapMatch;
                if (isPlain(impt)) {
                    mapMatch = getMapMatch(impt, outMappings);
                } else {
                    mapMatch = getMapMatch(impt = rebase(impt, this.mapUrl, this.rootUrl), outMappings) || this.rootUrl && getMapMatch(impt = rebase(impt, this.mapUrl, null), outMappings) || undefined;
                }
                if (mapMatch && impt.slice(mapMatch.length) === resolve(target, this.mapUrl, this.rootUrl).slice(resolve(outMappings[mapMatch], this.mapUrl, this.rootUrl).length)) {
                    continue;
                }
                let newbase = false;
                const targetParts = mappings[impt].split("/");
                const imptParts = impt.split("/");
                for(let j = imptParts.length - 1; j > 0; j--){
                    const subpath = imptParts.slice(j).join("/");
                    const subpathTarget = targetParts.slice(targetParts.length - (imptParts.length - j)).join("/");
                    if (subpath !== subpathTarget) {
                        outMappings[impt] = mappings[impt];
                        break;
                    }
                    const base = imptParts.slice(0, j).join("/") + "/";
                    if (outMappings[base]) continue;
                    const baseTarget = targetParts.slice(0, targetParts.length - (imptParts.length - j)).join("/") + "/";
                    // Dedupe existing mappings against the new base to remove them
                    // And if we dont dedupe against anything then dont perform this basing
                    for (let impt1 of Object.keys(outMappings)){
                        const target1 = outMappings[impt1];
                        let matches = false;
                        if (isPlain(impt1)) {
                            matches = impt1.startsWith(base);
                        } else {
                            matches = (impt1 = rebase(impt1, this.mapUrl, this.rootUrl)).startsWith(base) || (impt1 = rebase(impt1, this.mapUrl, this.rootUrl)).startsWith(base);
                        }
                        if (matches && impt1.slice(base.length) === resolve(target1, this.mapUrl, this.rootUrl).slice(resolve(baseTarget, this.mapUrl, this.rootUrl).length)) {
                            newbase = true;
                            delete outMappings[impt1];
                        }
                    }
                    if (newbase) {
                        outMappings[base] = baseTarget;
                        break;
                    }
                }
                if (!newbase) outMappings[impt] = target;
            }
            return outMappings;
        };
        // Only applies for scopes since "imports" are generally treated as
        // an authoritative entry point list
        for (const scope of Object.keys(this.scopes)){
            this.scopes[scope] = combineSubpathMappings(this.scopes[scope]);
        }
        return this;
    }
    /**
   * Groups the import map scopes to shared URLs to reduce duplicate mappings.
   *
   * For two given scopes, "https://site.com/x/" and "https://site.com/y/",
   * a single scope will be constructed for "https://site.com/" including
   * their shared mappings, only retaining the scopes if they have differences.
   *
   * In the case where the scope is on the same origin as the mapUrl, the grouped
   * scope is determined based on determining the common baseline over all local scopes
   *
   * @returns ImportMap for chaining
   */ flatten() {
        // First, determine the common base for the local mappings if any
        let localScopemapUrl = null;
        for (const scope of Object.keys(this.scopes)){
            const resolvedScope = resolve(scope, this.mapUrl, this.rootUrl);
            if (isURL(resolvedScope)) {
                const scopeUrl = new URL(resolvedScope);
                if (sameOrigin(scopeUrl, this.mapUrl)) {
                    if (!localScopemapUrl) localScopemapUrl = scopeUrl.href;
                    else localScopemapUrl = getCommonBase(scopeUrl.href, localScopemapUrl);
                }
            } else {
                if (!localScopemapUrl) localScopemapUrl = resolvedScope;
                else localScopemapUrl = getCommonBase(resolvedScope, localScopemapUrl);
            }
        }
        // for each scope, update its mappings to be in the shared base where possible
        const relativeLocalScopemapUrl = localScopemapUrl ? rebase(localScopemapUrl, this.mapUrl, this.rootUrl) : null;
        for (const scope1 of Object.keys(this.scopes)){
            const scopeImports = this.scopes[scope1];
            let scopemapUrl;
            const resolvedScope1 = resolve(scope1, this.mapUrl, this.rootUrl);
            if (isURL(resolvedScope1)) {
                const scopeUrl1 = new URL(resolvedScope1);
                if (sameOrigin(scopeUrl1, this.mapUrl)) {
                    scopemapUrl = relativeLocalScopemapUrl;
                } else {
                    scopemapUrl = scopeUrl1.protocol + "//" + scopeUrl1.hostname + (scopeUrl1.port ? ":" + scopeUrl1.port : "") + "/";
                }
            } else {
                scopemapUrl = relativeLocalScopemapUrl;
            }
            let scopeBase = this.scopes[scopemapUrl] || Object.create(null);
            if (scopeBase === scopeImports) scopeBase = null;
            let flattenedAll = true;
            for (const name of Object.keys(scopeImports)){
                const target = scopeImports[name];
                if (this.imports[name] && resolve(this.imports[name], this.mapUrl, this.rootUrl) === resolve(target, this.mapUrl, this.rootUrl)) {
                    delete scopeImports[name];
                } else if (scopeBase && (!scopeBase[name] || resolve(scopeBase[name], this.mapUrl, this.rootUrl) === resolve(target, this.mapUrl, this.rootUrl))) {
                    scopeBase[name] = rebase(target, this.mapUrl, this.rootUrl);
                    delete scopeImports[name];
                    this.scopes[scopemapUrl] = alphabetize(scopeBase);
                } else {
                    flattenedAll = false;
                }
            }
            if (flattenedAll) delete this.scopes[scope1];
        }
        return this;
    }
    /**
   * Rebase the entire import map to a new mapUrl and rootUrl
   *
   * If the rootUrl is not provided, it will remain null if it was
   * already set to null.
   *
   * Otherwise, just like the constructor options, the rootUrl
   * will default to the mapUrl base if it is an http: or https:
   * scheme URL, and null otherwise keeping absolute URLs entirely
   * in-tact.
   *
   * @param mapUrl The new map URL to use
   * @param rootUrl The new root URL to use
   * @returns ImportMap for chaining
   */ rebase(mapUrl = this.mapUrl, rootUrl) {
        if (typeof mapUrl === "string") mapUrl = new URL(mapUrl);
        if (rootUrl === undefined) {
            if (mapUrl.href === this.mapUrl.href) rootUrl = this.rootUrl;
            else rootUrl = this.rootUrl === null || mapUrl.protocol !== "https:" && mapUrl.protocol !== "http:" ? null : new URL("/", mapUrl);
        } else if (typeof rootUrl === "string") rootUrl = new URL(rootUrl);
        let changedImportProps = false;
        for (const impt of Object.keys(this.imports)){
            const target = this.imports[impt];
            this.imports[impt] = rebase(resolve(target, this.mapUrl, this.rootUrl), mapUrl, rootUrl);
            if (!isPlain(impt)) {
                const newImpt = rebase(resolve(impt, this.mapUrl, this.rootUrl), mapUrl, rootUrl);
                if (newImpt !== impt) {
                    changedImportProps = true;
                    this.imports[newImpt] = this.imports[impt];
                    delete this.imports[impt];
                }
            }
        }
        if (changedImportProps) this.imports = alphabetize(this.imports);
        let changedScopeProps = false;
        for (const scope of Object.keys(this.scopes)){
            const scopeImports = this.scopes[scope];
            let changedScopeImportProps = false;
            for (const impt1 of Object.keys(scopeImports)){
                const target1 = scopeImports[impt1];
                scopeImports[impt1] = rebase(resolve(target1, this.mapUrl, this.rootUrl), mapUrl, rootUrl);
                if (!isPlain(impt1)) {
                    const newName = rebase(resolve(impt1, this.mapUrl, this.rootUrl), mapUrl, rootUrl);
                    if (newName !== impt1) {
                        changedScopeImportProps = true;
                        scopeImports[newName] = scopeImports[impt1];
                        delete scopeImports[impt1];
                    }
                }
            }
            if (changedScopeImportProps) this.scopes[scope] = alphabetize(scopeImports);
            const newScope = rebase(resolve(scope, this.mapUrl, this.rootUrl), mapUrl, rootUrl);
            if (scope !== newScope) {
                changedScopeProps = true;
                delete this.scopes[scope];
                this.scopes[newScope] = scopeImports;
            }
        }
        if (changedScopeProps) this.scopes = alphabetize(this.scopes);
        this.mapUrl = mapUrl;
        this.rootUrl = rootUrl;
        return this;
    }
    /**
   * Perform a module resolution against the import map
   *
   * @param specifier Specifier to resolve
   * @param parentUrl Parent URL to resolve against
   * @returns Resolved URL string
   */ resolve(specifier, parentUrl = this.mapUrl) {
        if (typeof parentUrl !== "string") parentUrl = parentUrl.toString();
        parentUrl = resolve(parentUrl, this.mapUrl, this.rootUrl);
        let specifierUrl;
        if (!isPlain(specifier)) {
            specifierUrl = new URL(specifier, parentUrl);
            specifier = specifierUrl.href;
        }
        const scopeMatches = getScopeMatches(parentUrl, this.scopes, this.mapUrl, this.rootUrl);
        for (const [scope] of scopeMatches){
            let mapMatch = getMapMatch(specifier, this.scopes[scope]);
            if (!mapMatch && specifierUrl) {
                mapMatch = getMapMatch(specifier = rebase(specifier, this.mapUrl, this.rootUrl), this.scopes[scope]) || this.rootUrl && getMapMatch(specifier = rebase(specifier, this.mapUrl, null), this.scopes[scope]) || undefined;
            }
            if (mapMatch) {
                const target = this.scopes[scope][mapMatch];
                return resolve(target + specifier.slice(mapMatch.length), this.mapUrl, this.rootUrl);
            }
        }
        let mapMatch1 = getMapMatch(specifier, this.imports);
        if (!mapMatch1 && specifierUrl) {
            mapMatch1 = getMapMatch(specifier = rebase(specifier, this.mapUrl, this.rootUrl), this.imports) || this.rootUrl && getMapMatch(specifier = rebase(specifier, this.mapUrl, null), this.imports) || undefined;
        }
        if (mapMatch1) {
            const target1 = this.imports[mapMatch1];
            return resolve(target1 + specifier.slice(mapMatch1.length), this.mapUrl, this.rootUrl);
        }
        if (specifierUrl) return specifierUrl.href;
        throw new Error(`Unable to resolve ${specifier} in ${parentUrl}`);
    }
    /**
   * Get the import map JSON data
   *
   * @returns Import map data
   */ toJSON() {
        const obj = {};
        if (Object.keys(this.imports).length) obj.imports = this.imports;
        if (Object.keys(this.scopes).length) obj.scopes = this.scopes;
        return JSON.parse(JSON.stringify(obj));
    }
    /**
   * Create a new import map instance
   *
   * @param opts import map options, can be an optional bag of { map?, mapUrl?, rootUrl? } or just a direct mapUrl
   */ constructor(opts){
        this.imports = Object.create(null);
        this.scopes = Object.create(null);
        let { map , mapUrl =baseUrl , rootUrl ,  } = opts instanceof URL || typeof opts === "string" || typeof opts === "undefined" ? {
            mapUrl: opts,
            map: undefined,
            rootUrl: undefined
        } : opts;
        if (typeof mapUrl === "string") mapUrl = new URL(mapUrl);
        this.mapUrl = mapUrl;
        if (rootUrl === undefined && (this.mapUrl.protocol === "http:" || this.mapUrl.protocol === "https:")) rootUrl = new URL("/", this.mapUrl);
        else if (typeof rootUrl === "string") rootUrl = new URL(rootUrl);
        this.rootUrl = rootUrl || null;
        if (map) this.extend(map);
    }
}
function getScopeMatches(parentUrl, scopes, mapUrl, rootUrl) {
    let scopeCandidates = Object.keys(scopes).map((scope)=>[
            scope,
            resolve(scope, mapUrl, rootUrl), 
        ]);
    scopeCandidates = scopeCandidates.sort(([, matchA], [, matchB])=>matchA.length < matchB.length ? 1 : -1);
    return scopeCandidates.filter(([, scopeUrl])=>{
        return scopeUrl === parentUrl || scopeUrl.endsWith("/") && parentUrl.startsWith(scopeUrl);
    });
}
function getMapMatch(specifier, map) {
    if (specifier in map) return specifier;
    let curMatch;
    for (const match of Object.keys(map)){
        const wildcard = match.endsWith("*");
        if (!match.endsWith("/") && !wildcard) continue;
        if (specifier.startsWith(wildcard ? match.slice(0, -1) : match)) {
            if (!curMatch || match.length > curMatch.length) curMatch = match;
        }
    }
    return curMatch;
}

export { ImportMap, getMapMatch, getScopeMatches };
//# sourceMappingURL=map.js.map
