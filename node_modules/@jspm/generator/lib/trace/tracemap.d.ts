import { type InstallerOptions, InstallTarget, InstallMode } from "../install/installer.js";
import { Installer } from "../install/installer.js";
import { ImportMap, IImportMap } from "@jspm/import-map";
import { Resolver } from "./resolver.js";
import { Log } from "../common/log.js";
export interface TraceMapOptions extends InstallerOptions {
    /**
     * Whether or not to trace the dependency tree as systemJS modules.
     */
    system?: boolean;
    /**
     * Whether or not to try and trace dynamic imports.
     */
    static?: boolean;
    /**
     * Whether the import map is a full generic import map for the app, or an
     * exact trace for the provided entry points. (currently unused)
     */
    fullMap?: boolean;
    /**
     * List of module specifiers to ignore during tracing.
     */
    ignore?: string[];
    /**
     * Whether or not to enable CommonJS tracing for local dependencies.
     */
    commonJS?: boolean;
}
interface TraceGraph {
    [tracedUrls: string]: TraceEntry;
}
interface TraceEntry {
    promise: Promise<void> | null;
    deps: string[];
    dynamicDeps: string[];
    hasStaticParent: boolean;
    size: number;
    integrity: string;
    wasCjs: boolean;
    usesCjs: boolean;
    cjsLazyDeps: string[];
    format: "esm" | "commonjs" | "system" | "json" | "typescript" | "wasm";
}
interface VisitOpts {
    static?: boolean;
    toplevel: boolean;
    installMode: InstallMode;
    visitor?: (specifier: string, parentUrl: string, resolvedUrl: string, toplevel: boolean, entry: TraceEntry | null) => Promise<boolean | void>;
}
export default class TraceMap {
    installer: Installer | undefined;
    opts: TraceMapOptions;
    tracedUrls: TraceGraph;
    inputMap: ImportMap;
    mapUrl: URL;
    baseUrl: URL;
    rootUrl: URL | null;
    pins: Array<string>;
    log: Log;
    resolver: Resolver;
    /**
     * Lock to ensure no races against input map processing.
     * @type {Promise<void>}
     */
    processInputMap: Promise<void>;
    constructor(opts: TraceMapOptions, log: Log, resolver: Resolver);
    addInputMap(map: IImportMap, mapUrl?: URL, rootUrl?: URL | null, preloads?: string[]): Promise<void>;
    /**
     * Resolves, analyses and recursively visits the given module specifier and all of its dependencies.
     *
     * @param {string} specifier Module specifier to visit.
     * @param {VisitOpts} opts Visitor configuration.
     * @param {} parentUrl URL of the parent context for the specifier.
     * @param {} seen Cache for optimisation.
     */
    visit(specifier: string, opts: VisitOpts, parentUrl?: string, seen?: Set<unknown>): Promise<void>;
    extractMap(modules: string[]): Promise<{
        map: ImportMap;
        staticDeps: string[];
        dynamicDeps: string[];
    }>;
    startInstall(): void;
    finishInstall(modules?: string[]): Promise<{
        map: ImportMap;
        staticDeps: string[];
        dynamicDeps: string[];
    }>;
    add(name: string, target: InstallTarget, opts: InstallMode): Promise<void>;
    /**
     * @returns `resolved` - either a URL `string` pointing to the module or `null` if the specifier should be ignored.
     */
    resolve(specifier: string, parentUrl: string, installOpts: InstallMode, toplevel: boolean): Promise<string>;
    private getTraceEntry;
}
export {};
