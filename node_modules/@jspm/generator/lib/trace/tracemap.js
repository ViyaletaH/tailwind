import { importedFrom, isFetchProtocol, isPlain, isURL, resolveUrl } from "../common/url.js";
import { Installer } from "../install/installer.js";
import { JspmError, throwInternalError } from "../common/err.js";
import { parsePkg } from "../install/package.js";
// @ts-ignore
import { ImportMap, getMapMatch, getScopeMatches } from "@jspm/import-map";
import { isBuiltinScheme, isMappableScheme } from "./resolver.js";
import { mergeConstraints, mergeLocks, extractLockConstraintsAndMap } from "../install/lock.js";
function combineSubpaths(installSubpath, traceSubpath) {
    return installSubpath === null || installSubpath === "." || traceSubpath === "." ? installSubpath || traceSubpath : `${installSubpath}${traceSubpath.slice(1)}`;
}
class TraceMap {
    async addInputMap(map, mapUrl = this.mapUrl, rootUrl = this.rootUrl, preloads) {
        return this.processInputMap = this.processInputMap.then(async ()=>{
            const inMap = new ImportMap({
                map,
                mapUrl,
                rootUrl
            }).rebase(this.mapUrl, this.rootUrl);
            const pins = Object.keys(inMap.imports || []);
            for (const pin of pins){
                if (!this.pins.includes(pin)) this.pins.push(pin);
            }
            const { maps , locks , constraints  } = await extractLockConstraintsAndMap(inMap, preloads, mapUrl, rootUrl, this.installer.defaultRegistry, this.resolver, this.installer.defaultProvider);
            this.inputMap.extend(maps);
            mergeLocks(this.installer.installs, locks);
            mergeConstraints(this.installer.constraints, constraints);
        });
    }
    /**
   * Resolves, analyses and recursively visits the given module specifier and all of its dependencies.
   *
   * @param {string} specifier Module specifier to visit.
   * @param {VisitOpts} opts Visitor configuration.
   * @param {} parentUrl URL of the parent context for the specifier.
   * @param {} seen Cache for optimisation.
   */ async visit(specifier, opts, parentUrl = this.baseUrl.href, seen = new Set()) {
        var _this_opts_ignore;
        if (!parentUrl) throw new Error("Internal error: expected parentUrl");
        if ((_this_opts_ignore = this.opts.ignore) === null || _this_opts_ignore === void 0 ? void 0 : _this_opts_ignore.includes(specifier)) return;
        if (seen.has(`${specifier}##${parentUrl}`)) return;
        seen.add(`${specifier}##${parentUrl}`);
        this.log("tracemap/visit", `Attempting to resolve ${specifier} to a module from ${parentUrl}, toplevel=${opts.toplevel}, mode=${opts.installMode}`);
        const resolved = await this.resolve(specifier, parentUrl, opts.installMode, opts.toplevel);
        // We support analysis of CommonJS modules for local workflows, where it's
        // very likely that the user has some CommonJS dependencies, but this is
        // something that the user has to explicitly enable:
        const entry = await this.getTraceEntry(resolved, parentUrl);
        if ((entry === null || entry === void 0 ? void 0 : entry.format) === "commonjs" && entry.usesCjs && !this.opts.commonJS) {
            throw new JspmError(`Unable to trace ${resolved}, as it is a CommonJS module. Either enable CommonJS tracing explicitly by setting "GeneratorOptions.commonJS" to true, or use a provider that performs ESM transpiling like jspm.io via defaultProvider: 'jspm.io'.`);
        }
        if (opts.visitor) {
            const stop = await opts.visitor(specifier, parentUrl, resolved, opts.toplevel, entry);
            if (stop) return;
        }
        if (!entry) return;
        let allDeps = [
            ...entry.deps
        ];
        if (entry.dynamicDeps.length && !opts.static) {
            for (const dep of entry.dynamicDeps){
                if (!allDeps.includes(dep)) allDeps.push(dep);
            }
        }
        if (entry.cjsLazyDeps && !opts.static) {
            for (const dep of entry.cjsLazyDeps){
                if (!allDeps.includes(dep)) allDeps.push(dep);
            }
        }
        if (opts.toplevel && (isMappableScheme(specifier) || isPlain(specifier))) {
            opts = {
                ...opts,
                toplevel: false
            };
        }
        await Promise.all(allDeps.map(async (dep)=>{
            if (dep.indexOf("*") !== -1) {
                this.log("todo", "Handle wildcard trace " + dep + " in " + resolved);
                return;
            }
            await this.visit(dep, opts, resolved, seen);
        }));
    }
    async extractMap(modules) {
        const map = new ImportMap({
            mapUrl: this.mapUrl,
            rootUrl: this.rootUrl
        });
        // note this plucks custom top-level custom imports
        // we may want better control over this
        map.extend(this.inputMap);
        // re-drive all the traces to convergence
        do {
            this.installer.newInstalls = false;
            await Promise.all(modules.map(async (module)=>{
                await this.visit(module, {
                    installMode: "freeze",
                    static: this.opts.static,
                    toplevel: true
                });
            }));
        }while (this.installer.newInstalls)
        // The final loop gives us the mappings
        const staticList = new Set();
        const dynamicList = new Set();
        const dynamics = [];
        let list = staticList;
        const visitor = async (specifier, parentUrl, resolved, toplevel, entry)=>{
            if (!staticList.has(resolved)) list.add(resolved);
            if (entry) for (const dep of entry.dynamicDeps){
                dynamics.push([
                    dep,
                    resolved
                ]);
            }
            if (toplevel) {
                if (isPlain(specifier) || isMappableScheme(specifier)) {
                    var _this_tracedUrls, _this_tracedUrls_parentUrl;
                    const existing = map.imports[specifier];
                    if (!existing || existing !== resolved && ((_this_tracedUrls = this.tracedUrls) === null || _this_tracedUrls === void 0 ? void 0 : (_this_tracedUrls_parentUrl = _this_tracedUrls[parentUrl]) === null || _this_tracedUrls_parentUrl === void 0 ? void 0 : _this_tracedUrls_parentUrl.wasCjs)) {
                        map.set(specifier, resolved);
                    }
                }
            } else {
                if (isPlain(specifier) || isMappableScheme(specifier)) {
                    var _map_scopes_scopeUrl, _map_scopes_parentUrl;
                    const scopeUrl = await this.resolver.getPackageBase(parentUrl);
                    const existing = (_map_scopes_scopeUrl = map.scopes[scopeUrl]) === null || _map_scopes_scopeUrl === void 0 ? void 0 : _map_scopes_scopeUrl[specifier];
                    if (!existing) {
                        map.set(specifier, resolved, scopeUrl);
                    } else if (existing !== resolved && ((_map_scopes_parentUrl = map.scopes[parentUrl]) === null || _map_scopes_parentUrl === void 0 ? void 0 : _map_scopes_parentUrl[specifier]) !== resolved) {
                        map.set(specifier, resolved, parentUrl);
                    }
                }
            }
        };
        const seen = new Set();
        await Promise.all(modules.map(async (module)=>{
            await this.visit(module, {
                static: true,
                visitor,
                installMode: "freeze",
                toplevel: true
            }, this.baseUrl.href, seen);
        }));
        list = dynamicList;
        await Promise.all(dynamics.map(async ([specifier, parent])=>{
            await this.visit(specifier, {
                visitor,
                installMode: "freeze",
                toplevel: false
            }, parent, seen);
        }));
        if (this.installer.newInstalls) {
        // Disabled as it obscures valid errors
        // console.warn('Unexpected resolution divergence.');
        }
        return {
            map,
            staticDeps: [
                ...staticList
            ],
            dynamicDeps: [
                ...dynamicList
            ]
        };
    }
    startInstall() {
        this.installer.startInstall();
    }
    async finishInstall(modules = this.pins) {
        const result = await this.extractMap(modules);
        this.installer.finishInstall();
        return result;
    }
    async add(name, target, opts) {
        await this.installer.installTarget(name, target, null, opts, null, this.mapUrl.href);
    }
    /**
   * @returns `resolved` - either a URL `string` pointing to the module or `null` if the specifier should be ignored.
   */ async resolve(specifier, parentUrl, installOpts, toplevel) {
        var _this_tracedUrls_parentUrl, _this_tracedUrls_parentUrl1;
        const cjsEnv = (_this_tracedUrls_parentUrl = this.tracedUrls[parentUrl]) === null || _this_tracedUrls_parentUrl === void 0 ? void 0 : _this_tracedUrls_parentUrl.wasCjs;
        const parentPkgUrl = await this.resolver.getPackageBase(parentUrl);
        if (!parentPkgUrl) throwInternalError();
        const parentIsCjs = ((_this_tracedUrls_parentUrl1 = this.tracedUrls[parentUrl]) === null || _this_tracedUrls_parentUrl1 === void 0 ? void 0 : _this_tracedUrls_parentUrl1.format) === "commonjs";
        if ((!isPlain(specifier) || specifier === "..") && !isMappableScheme(specifier)) {
            let resolvedUrl = new URL(specifier, parentUrl);
            if (!isFetchProtocol(resolvedUrl.protocol)) throw new JspmError(`Found unexpected protocol ${resolvedUrl.protocol}${importedFrom(parentUrl)}`);
            const resolvedHref = resolvedUrl.href;
            let finalized = await this.resolver.realPath(await this.resolver.finalizeResolve(resolvedHref, parentIsCjs, parentPkgUrl));
            // handle URL mappings
            const urlResolved = this.inputMap.resolve(finalized, parentUrl);
            // TODO: avoid this hack - perhaps solved by conditional maps
            if (urlResolved !== finalized && !urlResolved.startsWith("node:") && !urlResolved.startsWith("deno:")) {
                finalized = urlResolved;
            }
            if (finalized !== resolvedHref) {
                this.inputMap.set(resolvedHref.endsWith("/") ? resolvedHref.slice(0, -1) : resolvedHref, finalized);
                resolvedUrl = new URL(finalized);
            }
            this.log("tracemap/resolve", `${specifier} ${parentUrl} -> ${resolvedUrl} (URL resolution)`);
            return resolvedUrl.href;
        }
        // Subscope override
        const scopeMatches = getScopeMatches(parentUrl, this.inputMap.scopes, this.inputMap.mapUrl);
        const pkgSubscopes = scopeMatches.filter(([, url])=>url.startsWith(parentPkgUrl));
        if (pkgSubscopes.length) {
            for (const [scope] of pkgSubscopes){
                const mapMatch = getMapMatch(specifier, this.inputMap.scopes[scope]);
                if (mapMatch) {
                    const resolved = await this.resolver.realPath(resolveUrl(this.inputMap.scopes[scope][mapMatch] + specifier.slice(mapMatch.length), this.inputMap.mapUrl, this.inputMap.rootUrl));
                    this.log("tracemap/resolve", `${specifier} ${parentUrl} -> ${resolved} (subscope resolution)`);
                    return resolved;
                }
            }
        }
        // Scope override
        // TODO: isn't this subsumed by previous check?
        const userScopeMatch = scopeMatches.find(([, url])=>url === parentPkgUrl);
        if (userScopeMatch) {
            const imports = this.inputMap.scopes[userScopeMatch[0]];
            const userImportsMatch = getMapMatch(specifier, imports);
            const userImportsResolved = userImportsMatch ? await this.resolver.realPath(resolveUrl(imports[userImportsMatch] + specifier.slice(userImportsMatch.length), this.inputMap.mapUrl, this.inputMap.rootUrl)) : null;
            if (userImportsResolved) {
                this.log("tracemap/resolve", `${specifier} ${parentUrl} -> ${userImportsResolved} (scope resolution)`);
                return userImportsResolved;
            }
        }
        // User import overrides
        const userImportsMatch = getMapMatch(specifier, this.inputMap.imports);
        const userImportsResolved = userImportsMatch ? await this.resolver.realPath(resolveUrl(this.inputMap.imports[userImportsMatch] + specifier.slice(userImportsMatch.length), this.inputMap.mapUrl, this.inputMap.rootUrl)) : null;
        if (userImportsResolved) {
            this.log("tracemap/resolve", `${specifier} ${parentUrl} -> ${userImportsResolved} (imports resolution)`);
            return userImportsResolved;
        }
        const parsed = parsePkg(specifier);
        if (!parsed) throw new JspmError(`Invalid package name ${specifier}`);
        const { pkgName , subpath  } = parsed;
        // Own name import
        const pcfg = await this.resolver.getPackageConfig(parentPkgUrl) || {};
        if (pcfg.exports && pcfg.name === pkgName) {
            const resolved = await this.resolver.realPath(await this.resolver.resolveExport(parentPkgUrl, subpath, cjsEnv, parentIsCjs, specifier, this.installer, new URL(parentUrl)));
            this.log("tracemap/resolve", `${specifier} ${parentUrl} -> ${resolved} (package own-name resolution)`);
            return resolved;
        }
        // Imports
        if (pcfg.imports && pkgName[0] === "#") {
            const match = getMapMatch(specifier, pcfg.imports);
            if (!match) throw new JspmError(`No '${specifier}' import defined in ${parentPkgUrl}${importedFrom(parentUrl)}.`);
            const target = this.resolver.resolvePackageTarget(pcfg.imports[match], parentPkgUrl, cjsEnv, specifier.slice(match.length), true);
            if (!isURL(target)) {
                return this.resolve(target, parentUrl, installOpts, toplevel);
            }
            const resolved = await this.resolver.realPath(target);
            this.log("tracemap/resolve", `${specifier} ${parentUrl} -> ${resolved} (package imports resolution)`);
            return resolved;
        }
        // @ts-ignore
        const installed = await this.installer.install(pkgName, installOpts, toplevel ? null : parentPkgUrl, subpath, parentUrl);
        if (typeof installed === "string") {
            return installed;
        } else if (installed) {
            const { installUrl , installSubpath  } = installed;
            const resolved = await this.resolver.realPath(await this.resolver.resolveExport(installUrl, combineSubpaths(installSubpath, subpath), cjsEnv, parentIsCjs, specifier, this.installer, new URL(parentUrl)));
            this.log("tracemap/resolve", `${specifier} ${parentUrl} -> ${resolved} (installation resolution)`);
            return resolved;
        }
        throw new JspmError(`No resolution in map for ${specifier}${importedFrom(parentUrl)}`);
    }
    async getTraceEntry(resolvedUrl, parentUrl) {
        if (resolvedUrl in this.tracedUrls) {
            const entry = this.tracedUrls[resolvedUrl];
            await entry.promise;
            return entry;
        }
        if (isBuiltinScheme(resolvedUrl)) return null;
        if (resolvedUrl.endsWith("/")) throw new JspmError(`Trailing "/" installs not supported installing ${resolvedUrl} for ${parentUrl}`);
        const traceEntry = this.tracedUrls[resolvedUrl] = {
            promise: null,
            wasCjs: false,
            usesCjs: false,
            deps: null,
            dynamicDeps: null,
            cjsLazyDeps: null,
            hasStaticParent: true,
            size: NaN,
            integrity: "",
            format: undefined
        };
        traceEntry.promise = (async ()=>{
            var _this_tracedUrls_parentUrl;
            const parentIsCjs = ((_this_tracedUrls_parentUrl = this.tracedUrls[parentUrl]) === null || _this_tracedUrls_parentUrl === void 0 ? void 0 : _this_tracedUrls_parentUrl.format) === "commonjs";
            const { deps , dynamicDeps , cjsLazyDeps , size , format , usesCjs  } = await this.resolver.analyze(resolvedUrl, parentUrl, this.opts.system, parentIsCjs);
            traceEntry.format = format;
            traceEntry.size = size;
            traceEntry.deps = deps.sort();
            traceEntry.dynamicDeps = dynamicDeps.sort();
            traceEntry.cjsLazyDeps = cjsLazyDeps ? cjsLazyDeps.sort() : cjsLazyDeps;
            // wasCJS distinct from CJS because it applies to CJS transformed into ESM
            // from the resolver perspective
            const wasCJS = format === "commonjs" || await this.resolver.wasCommonJS(resolvedUrl);
            if (wasCJS) traceEntry.wasCjs = true;
            traceEntry.promise = null;
        })();
        await traceEntry.promise;
        return traceEntry;
    }
    constructor(opts, log, resolver){
        this.tracedUrls = {};
        this.pins = [];
        /**
   * Lock to ensure no races against input map processing.
   * @type {Promise<void>}
   */ this.processInputMap = Promise.resolve();
        this.log = log;
        this.resolver = resolver;
        this.mapUrl = opts.mapUrl;
        this.baseUrl = opts.baseUrl;
        this.rootUrl = opts.rootUrl || null;
        this.opts = opts;
        this.inputMap = new ImportMap({
            mapUrl: this.mapUrl,
            rootUrl: this.rootUrl
        });
        this.installer = new Installer(this.mapUrl.pathname.endsWith("/") ? this.mapUrl.href : `${this.mapUrl.href}/`, this.opts, this.log, this.resolver);
    }
}
// The tracemap fully drives the installer
export { TraceMap as default };


//# sourceMappingURL=tracemap.js.map